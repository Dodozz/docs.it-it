---
title: Tipi e variabili C# - Panoramica del linguaggio C#
description: Informazioni sulla definizione di tipi e la dichiarazione di variabili nel linguaggio C#
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: 552066ff8d17d49dc5cc0bbb60b05c9c3e5f8eda
ms.sourcegitcommit: 859b2ba0c74a1a5a4ad0d59a3c3af23450995981
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/11/2019
ms.locfileid: "59481080"
---
# <a name="types-and-variables"></a><span data-ttu-id="6781d-103">Tipi e variabili</span><span class="sxs-lookup"><span data-stu-id="6781d-103">Types and variables</span></span>

<span data-ttu-id="6781d-104">In C# esistono due generi di tipi: *tipi valore* e *tipi riferimento*.</span><span class="sxs-lookup"><span data-stu-id="6781d-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="6781d-105">Le variabili dei tipi valore contengono direttamente i propri dati, mentre le variabili dei tipi riferimento archiviano i riferimenti ai propri dati, noti come oggetti.</span><span class="sxs-lookup"><span data-stu-id="6781d-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="6781d-106">Con i tipi riferimento, due variabili possono fare riferimento allo stesso oggetto e di conseguenza le operazioni su una delle due variabili possono influire sull'oggetto a cui fa riferimento l'altra.</span><span class="sxs-lookup"><span data-stu-id="6781d-106">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="6781d-107">Con i tipi valore, ogni variabile ha una propria copia dei dati e non è possibile che le operazioni su una variabile influiscano sull'altra (tranne nel caso delle variabili di parametro `ref` e `out`).</span><span class="sxs-lookup"><span data-stu-id="6781d-107">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="6781d-108">I tipi valore di C# sono ulteriormente suddivisi in *tipi semplici*, *tipi enum*, *tipi struct* e *tipi valore nullable*.</span><span class="sxs-lookup"><span data-stu-id="6781d-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="6781d-109">I tipi riferimento di C# sono ulteriormente suddivisi in *tipi classe*, *tipi interfaccia*, *tipi matrice* e *tipi delegato*.</span><span class="sxs-lookup"><span data-stu-id="6781d-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="6781d-110">Di seguito viene offerta una panoramica del sistema di tipi di C#.</span><span class="sxs-lookup"><span data-stu-id="6781d-110">The following provides an overview of C#’s type system.</span></span>

* <span data-ttu-id="6781d-111">Tipi valore</span><span class="sxs-lookup"><span data-stu-id="6781d-111">Value types</span></span>
  - <span data-ttu-id="6781d-112">Tipi semplici</span><span class="sxs-lookup"><span data-stu-id="6781d-112">Simple Types</span></span>
    * <span data-ttu-id="6781d-113">Integrale firmato: `sbyte`, `short`, `int`,</span><span class="sxs-lookup"><span data-stu-id="6781d-113">Signed integral: `sbyte`, `short`, `int`,</span></span> `long`
    * <span data-ttu-id="6781d-114">Integrale non firmato: `byte`, `ushort`, `uint`,</span><span class="sxs-lookup"><span data-stu-id="6781d-114">Unsigned integral: `byte`, `ushort`, `uint`,</span></span> `ulong`
    * <span data-ttu-id="6781d-115">Caratteri Unicode:</span><span class="sxs-lookup"><span data-stu-id="6781d-115">Unicode characters:</span></span> `char`
    * <span data-ttu-id="6781d-116">Virgola mobile IEEE: `float`,</span><span class="sxs-lookup"><span data-stu-id="6781d-116">IEEE floating point: `float`,</span></span> `double`
    * <span data-ttu-id="6781d-117">Decimale ad alta precisione:</span><span class="sxs-lookup"><span data-stu-id="6781d-117">High-precision decimal:</span></span> `decimal`
    * <span data-ttu-id="6781d-118">Booleano:</span><span class="sxs-lookup"><span data-stu-id="6781d-118">Boolean:</span></span> `bool`
  - <span data-ttu-id="6781d-119">Tipi enum</span><span class="sxs-lookup"><span data-stu-id="6781d-119">Enum types</span></span>
    * <span data-ttu-id="6781d-120">Tipi definiti dall'utente nel formato</span><span class="sxs-lookup"><span data-stu-id="6781d-120">User-defined types of the form</span></span> `enum E {...}`
  - <span data-ttu-id="6781d-121">Tipi struct</span><span class="sxs-lookup"><span data-stu-id="6781d-121">Struct types</span></span>
    * <span data-ttu-id="6781d-122">Tipi definiti dall'utente nel formato</span><span class="sxs-lookup"><span data-stu-id="6781d-122">User-defined types of the form</span></span> `struct S {...}`
  - <span data-ttu-id="6781d-123">Tipi valore nullable</span><span class="sxs-lookup"><span data-stu-id="6781d-123">Nullable value types</span></span>
    * <span data-ttu-id="6781d-124">Estensioni di tutti gli altri tipi valore con un valore `null`</span><span class="sxs-lookup"><span data-stu-id="6781d-124">Extensions of all other value types with a `null` value</span></span>
* <span data-ttu-id="6781d-125">Tipi riferimento</span><span class="sxs-lookup"><span data-stu-id="6781d-125">Reference types</span></span>
  - <span data-ttu-id="6781d-126">Tipi classe</span><span class="sxs-lookup"><span data-stu-id="6781d-126">Class types</span></span>
    * <span data-ttu-id="6781d-127">Classe di base principale di tutti gli altri tipi:</span><span class="sxs-lookup"><span data-stu-id="6781d-127">Ultimate base class of all other types:</span></span> `object`
    * <span data-ttu-id="6781d-128">Stringhe Unicode:</span><span class="sxs-lookup"><span data-stu-id="6781d-128">Unicode strings:</span></span> `string`
    * <span data-ttu-id="6781d-129">Tipi definiti dall'utente nel formato</span><span class="sxs-lookup"><span data-stu-id="6781d-129">User-defined types of the form</span></span> `class C {...}`
  - <span data-ttu-id="6781d-130">Tipi interfaccia</span><span class="sxs-lookup"><span data-stu-id="6781d-130">Interface types</span></span>
    * <span data-ttu-id="6781d-131">Tipi definiti dall'utente nel formato</span><span class="sxs-lookup"><span data-stu-id="6781d-131">User-defined types of the form</span></span> `interface I {...}`
  - <span data-ttu-id="6781d-132">Tipi matrice</span><span class="sxs-lookup"><span data-stu-id="6781d-132">Array types</span></span>
    * <span data-ttu-id="6781d-133">Unidimensionale e multidimensionale, ad esempio `int[]` e</span><span class="sxs-lookup"><span data-stu-id="6781d-133">Single- and multi-dimensional, for example, `int[]` and</span></span> `int[,]`
  - <span data-ttu-id="6781d-134">Tipi delegato</span><span class="sxs-lookup"><span data-stu-id="6781d-134">Delegate types</span></span>
    * <span data-ttu-id="6781d-135">Tipi definiti dall'utente nel formato</span><span class="sxs-lookup"><span data-stu-id="6781d-135">User-defined types of the form</span></span> `delegate int D(...)`

<span data-ttu-id="6781d-136">Gli otto tipi integrali offrono supporto per i valori a 8, 16, 32 e 64 bit in formato con segno o senza segno.</span><span class="sxs-lookup"><span data-stu-id="6781d-136">The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</span></span>

<span data-ttu-id="6781d-137">I due tipi a virgola mobile, `float` e `double`, vengono rappresentati mediante, rispettivamente, i formati IEC-60559 a 32 bit a precisione singola e IEC-60559 a 64 bit a precisione doppia.</span><span class="sxs-lookup"><span data-stu-id="6781d-137">The two floating-point types, `float` and `double`, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</span></span>

<span data-ttu-id="6781d-138">Il tipo `decimal` è un tipo dati a 128 bit adatto per i calcoli finanziari e monetari.</span><span class="sxs-lookup"><span data-stu-id="6781d-138">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span>

<span data-ttu-id="6781d-139">Il tipo `bool` di C# viene usato per rappresentare valori booleani, ovvero valori che sono `true` o `false`.</span><span class="sxs-lookup"><span data-stu-id="6781d-139">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="6781d-140">Per l'elaborazione di caratteri e stringhe, in C# viene usata la codifica Unicode.</span><span class="sxs-lookup"><span data-stu-id="6781d-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="6781d-141">Il tipo `char` rappresenta un'unità di codice UTF-16, mentre il tipo `string` rappresenta una sequenza di unità di codice UTF-16.</span><span class="sxs-lookup"><span data-stu-id="6781d-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="6781d-142">Di seguito vengono riepilogati i tipi numerici di C#.</span><span class="sxs-lookup"><span data-stu-id="6781d-142">This summarizes C#’s numeric types.</span></span>

* <span data-ttu-id="6781d-143">Signed Integer</span><span class="sxs-lookup"><span data-stu-id="6781d-143">Signed Integral</span></span>
  - `sbyte`<span data-ttu-id="6781d-144">:  8 bit, intervallo compreso tra -128 e 127</span><span class="sxs-lookup"><span data-stu-id="6781d-144">:  8 bits, range from -128 to 127</span></span>
  - `short`<span data-ttu-id="6781d-145">: 16 bit, intervallo compreso tra -32.768 e 32.767</span><span class="sxs-lookup"><span data-stu-id="6781d-145">: 16 bits, range from -32,768 to 32,767</span></span>
  - `int`  <span data-ttu-id="6781d-146">: 32 bit, intervallo compreso tra -2.147.483.648 e 2.147.483.647</span><span class="sxs-lookup"><span data-stu-id="6781d-146">: 32 bits, range from -2,147,483,648 to 2,147,483,647</span></span>
  - `long` <span data-ttu-id="6781d-147">: 64 bit, intervallo compreso tra -9.223.372.036.854.775.808 e 9.223.372.036.854.775.807</span><span class="sxs-lookup"><span data-stu-id="6781d-147">: 64 bits, range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></span>
* <span data-ttu-id="6781d-148">Unsigned Integer</span><span class="sxs-lookup"><span data-stu-id="6781d-148">Unsigned integral</span></span>
  - `byte`   <span data-ttu-id="6781d-149">:  8 bit, intervallo compreso tra 0 e 255</span><span class="sxs-lookup"><span data-stu-id="6781d-149">:  8 bits, range from 0 to 255</span></span>
  - `ushort` <span data-ttu-id="6781d-150">: 16 bit, intervallo compreso tra 0 e 65.535</span><span class="sxs-lookup"><span data-stu-id="6781d-150">: 16 bits, range from 0 to 65,535</span></span>
  - `uint`   <span data-ttu-id="6781d-151">: 32 bit, intervallo compreso tra 0 e 4.294.967.295</span><span class="sxs-lookup"><span data-stu-id="6781d-151">: 32 bits, range from 0 to 4,294,967,295</span></span>
  - `ulong`  <span data-ttu-id="6781d-152">: 64 bit, intervallo compreso tra 0 e 18.446.744.073.709.551.615</span><span class="sxs-lookup"><span data-stu-id="6781d-152">: 64 bits, range from 0 to 18,446,744,073,709,551,615</span></span>
* <span data-ttu-id="6781d-153">Virgola mobile</span><span class="sxs-lookup"><span data-stu-id="6781d-153">Floating point</span></span>
  - `float`  <span data-ttu-id="6781d-154">: 32 bit, intervallo compreso tra 1,5 x 10<sup>-45</sup> e 3,4 × 10<sup>38</sup>, precisione di 7 cifre</span><span class="sxs-lookup"><span data-stu-id="6781d-154">: 32 bits, range from 1.5 × 10<sup>-45</sup> to 3.4 × 10<sup>38</sup>,    7-digit precision</span></span>
  - `double` <span data-ttu-id="6781d-155">: 64 bit, intervallo compreso tra 5,0 × 10<sup>-324</sup> e 1,7 × 10<sup>308</sup>, precisione di 15 cifre</span><span class="sxs-lookup"><span data-stu-id="6781d-155">: 64 bits, range from 5.0 × 10<sup>-324</sup> to 1.7 × 10<sup>308</sup>, 15-digit precision</span></span>
* <span data-ttu-id="6781d-156">Decimale</span><span class="sxs-lookup"><span data-stu-id="6781d-156">Decimal</span></span>
  - `decimal` <span data-ttu-id="6781d-157">: 128 bit, intervallo compreso almeno tra -7,9 × 10<sup>-28</sup> e 7,9 × 10<sup>28</sup>, con precisione di almeno 28 cifre</span><span class="sxs-lookup"><span data-stu-id="6781d-157">: 128 bits, range is at least -7.9 × 10<sup>-28</sup> to 7.9 × 10<sup>28</sup>, with at least 28-digit precision</span></span>

<span data-ttu-id="6781d-158">I programmi C# usano le *dichiarazioni di tipo* per creare nuovi tipi.</span><span class="sxs-lookup"><span data-stu-id="6781d-158">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="6781d-159">Una dichiarazione di tipo consente di specificare il nome e i membri del nuovo tipo.</span><span class="sxs-lookup"><span data-stu-id="6781d-159">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="6781d-160">Cinque delle categorie di tipi di C# possono essere definite dall'utente: tipi classe, tipi struct, tipi interfaccia, tipi enum e tipi delegato.</span><span class="sxs-lookup"><span data-stu-id="6781d-160">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="6781d-161">Un tipo `class` definisce una struttura dati contenente membri dati (campi) e membri funzione (metodi, proprietà e altro).</span><span class="sxs-lookup"><span data-stu-id="6781d-161">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="6781d-162">I tipi classe supportano l'ereditarietà singola e il polimorfismo, meccanismi in base ai quali le classi derivate possono estendere e specializzare le classi di base.</span><span class="sxs-lookup"><span data-stu-id="6781d-162">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="6781d-163">Un tipo `struct` è simile a un tipo classe in quanto rappresenta una struttura con membri dati e membri funzione.</span><span class="sxs-lookup"><span data-stu-id="6781d-163">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="6781d-164">A differenza delle classi, tuttavia, i tipi struct sono tipi valore e non richiedono in genere l'allocazione dell'heap.</span><span class="sxs-lookup"><span data-stu-id="6781d-164">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="6781d-165">I tipi struct non supportano l'ereditarietà specificata dall'utente. Tutti i tipi struct ereditano implicitamente dal tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="6781d-165">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="6781d-166">Un tipo `interface` definisce un contratto come un set denominato di membri funzione pubblici.</span><span class="sxs-lookup"><span data-stu-id="6781d-166">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="6781d-167">Un tipo `class` o `struct` che implementa un tipo `interface` deve fornire le implementazioni dei membri funzione dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="6781d-167">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="6781d-168">Un tipo `interface` può ereditare da più interfacce di base e un tipo `class` o `struct` può implementare più interfacce.</span><span class="sxs-lookup"><span data-stu-id="6781d-168">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="6781d-169">Un tipo `delegate` rappresenta i riferimenti ai metodi, con un elenco di parametri e un tipo restituito particolari.</span><span class="sxs-lookup"><span data-stu-id="6781d-169">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="6781d-170">I delegati consentono di trattare i metodi come entità che è possibile assegnare a variabili e passare come parametri.</span><span class="sxs-lookup"><span data-stu-id="6781d-170">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="6781d-171">I delegati sono analoghi ai tipi funzione forniti dai linguaggi funzionali.</span><span class="sxs-lookup"><span data-stu-id="6781d-171">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="6781d-172">Sono inoltre simili al concetto di puntatori a funzione disponibili in altri linguaggi. A differenza dei puntatori a funzione, tuttavia, i delegati sono orientati agli oggetti e indipendenti dai tipi.</span><span class="sxs-lookup"><span data-stu-id="6781d-172">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="6781d-173">I tipi `class`, `struct`, `interface` e `delegate` supportano tutti generics, in base ai quali possono essere parametrizzati con altri tipi.</span><span class="sxs-lookup"><span data-stu-id="6781d-173">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="6781d-174">Un tipo `enum` è un tipo distinto con costanti denominate.</span><span class="sxs-lookup"><span data-stu-id="6781d-174">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="6781d-175">Ogni tipo `enum` ha un tipo sottostante, che deve essere uno degli otto tipi integrali.</span><span class="sxs-lookup"><span data-stu-id="6781d-175">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="6781d-176">Il set di valori di un tipo `enum` coincide con il set di valori del tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="6781d-176">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="6781d-177">C# supporta matrici unidimensionali e multidimensionali di qualsiasi tipo.</span><span class="sxs-lookup"><span data-stu-id="6781d-177">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="6781d-178">A differenza dei tipi elencati in precedenza, i tipi matrice non devono essere dichiarati prima dell'uso.</span><span class="sxs-lookup"><span data-stu-id="6781d-178">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="6781d-179">Al contrario, i tipi matrice vengono costruiti facendo seguire a un nome di tipo delle parentesi quadre.</span><span class="sxs-lookup"><span data-stu-id="6781d-179">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="6781d-180">Ad esempio, `int[]` è una matrice unidimensionale di `int`, `int[,]` è una matrice bidimensionale di `int` e `int[][]` è una matrice unidimensionale di matrici unidimensionali di `int`.</span><span class="sxs-lookup"><span data-stu-id="6781d-180">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="6781d-181">Anche i tipi valore nullable non devono essere dichiarati prima dell'uso.</span><span class="sxs-lookup"><span data-stu-id="6781d-181">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="6781d-182">Per ciascun tipo valore non-nullable `T` è presente un corrispondente tipo valore nullable `T?`, che può contenere un valore aggiuntivo `null`.</span><span class="sxs-lookup"><span data-stu-id="6781d-182">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="6781d-183">Ad esempio, `int?` è un tipo che può contenere qualsiasi Integer a 32 bit o il valore `null`.</span><span class="sxs-lookup"><span data-stu-id="6781d-183">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="6781d-184">Il sistema di tipi di C# è unificato in modo tale che un valore di qualsiasi tipo può essere trattato come un `object`.</span><span class="sxs-lookup"><span data-stu-id="6781d-184">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="6781d-185">In C# ogni tipo deriva direttamente o indirettamente dal tipo classe `object` e `object` è la classe di base principale di tutti i tipi.</span><span class="sxs-lookup"><span data-stu-id="6781d-185">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="6781d-186">I valori dei tipi riferimento vengono trattati come oggetti semplicemente visualizzando tali valori come tipi `object`.</span><span class="sxs-lookup"><span data-stu-id="6781d-186">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="6781d-187">I valori dei tipi valore vengono trattati come oggetti mediante l'esecuzione di operazioni di *boxing* e *unboxing*.</span><span class="sxs-lookup"><span data-stu-id="6781d-187">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="6781d-188">Nell'esempio seguente un valore `int` viene convertito in `object` e quindi convertito nuovamente in `int`.</span><span class="sxs-lookup"><span data-stu-id="6781d-188">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="6781d-189">Quando un valore di un tipo valore viene convertito in un tipo `object`, un'istanza di `object`, denominata anche "box", viene allocata per contenere tale valore. Quest'ultimo viene copiato nel box.</span><span class="sxs-lookup"><span data-stu-id="6781d-189">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="6781d-190">Al contrario, quando viene eseguito il cast di un riferimento `object` a un tipo valore, il sistema effettua un controllo per verificare che l'`object` a cui viene fatto riferimento sia un box del tipo valore corretto. Se il controllo ha esito positivo, il valore presente nel box viene copiato.</span><span class="sxs-lookup"><span data-stu-id="6781d-190">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="6781d-191">Con il sistema di tipi unificato di C#, i tipi valore possono diventare oggetti "su richiesta".</span><span class="sxs-lookup"><span data-stu-id="6781d-191">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="6781d-192">Grazie all'unificazione, le librerie generiche che usano il tipo `object` possono essere usate con entrambi i tipi riferimento e valore.</span><span class="sxs-lookup"><span data-stu-id="6781d-192">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="6781d-193">In C# sono disponibili diversi tipi di *variabili*, inclusi campi, elementi matrice, variabili locali e parametri.</span><span class="sxs-lookup"><span data-stu-id="6781d-193">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="6781d-194">Le variabili rappresentano posizioni di archiviazione e ogni variabile dispone di un tipo che determina quali valori possono essere archiviati nella variabile stessa, come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="6781d-194">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

* <span data-ttu-id="6781d-195">Tipo valore non-nullable</span><span class="sxs-lookup"><span data-stu-id="6781d-195">Non-nullable value type</span></span>
  - <span data-ttu-id="6781d-196">Valore esattamente del tipo indicato</span><span class="sxs-lookup"><span data-stu-id="6781d-196">A value of that exact type</span></span>
* <span data-ttu-id="6781d-197">Tipo valore nullable</span><span class="sxs-lookup"><span data-stu-id="6781d-197">Nullable value type</span></span>
  - <span data-ttu-id="6781d-198">Valore `null` o valore esattamente del tipo indicato</span><span class="sxs-lookup"><span data-stu-id="6781d-198">A `null` value or a value of that exact type</span></span>
* <span data-ttu-id="6781d-199">object</span><span class="sxs-lookup"><span data-stu-id="6781d-199">object</span></span>
  - <span data-ttu-id="6781d-200">Riferimento `null`, riferimento a un oggetto di qualsiasi tipo riferimento oppure riferimento a un valore boxed di qualsiasi tipo valore</span><span class="sxs-lookup"><span data-stu-id="6781d-200">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
* <span data-ttu-id="6781d-201">Tipo classe</span><span class="sxs-lookup"><span data-stu-id="6781d-201">Class type</span></span>
  - <span data-ttu-id="6781d-202">Riferimento `null`, riferimento a un'istanza del tipo classe oppure riferimento a un'istanza di una classe derivata dal tipo classe</span><span class="sxs-lookup"><span data-stu-id="6781d-202">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
* <span data-ttu-id="6781d-203">Tipo interfaccia</span><span class="sxs-lookup"><span data-stu-id="6781d-203">Interface type</span></span>
  - <span data-ttu-id="6781d-204">Riferimento `null`, riferimento a un'istanza di un tipo classe che implementa il tipo interfaccia oppure riferimento a un valore boxed di un tipo valore che implementa il tipo interfaccia</span><span class="sxs-lookup"><span data-stu-id="6781d-204">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
* <span data-ttu-id="6781d-205">Tipo matrice</span><span class="sxs-lookup"><span data-stu-id="6781d-205">Array type</span></span>
  - <span data-ttu-id="6781d-206">Riferimento `null`, riferimento a un'istanza del tipo matrice oppure riferimento a un'istanza di un tipo matrice compatibile</span><span class="sxs-lookup"><span data-stu-id="6781d-206">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
* <span data-ttu-id="6781d-207">Tipo delegato</span><span class="sxs-lookup"><span data-stu-id="6781d-207">Delegate type</span></span>
  - <span data-ttu-id="6781d-208">Riferimento `null` oppure riferimento a un'istanza di un tipo delegato compatibile</span><span class="sxs-lookup"><span data-stu-id="6781d-208">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="6781d-209">[Precedente](program-structure.md)
> [Successivo](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="6781d-209">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
