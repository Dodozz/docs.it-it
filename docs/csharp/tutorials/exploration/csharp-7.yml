### YamlMime:Tutorial
title: <span data-ttu-id="f9aad-101">Esplorare C# 7.0 - Esercitazione interattiva su C#</span><span class="sxs-lookup"><span data-stu-id="f9aad-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Esplorare C# 7.0 - Provare le nuove funzionalità in C# 7.0 in modo interattivo, usando il browser
  description: In questa esercitazione si userà il browser per esplorare C# 7.0 in modo interattivo. Si esamineranno i nuovi elementi che è possibile usare con C# 7.0 e che rendono il codice più conciso e leggibile.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 70f4e93460c69b54702f160d502163827ec73218
  ms.sourcegitcommit: 0aca6c5d166d7961a1e354c248495645b97a1dc5
  ms.translationtype: HT
  ms.contentlocale: it-IT
  ms.lasthandoff: 03/30/2019
  ms.locfileid: "58675523"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="f9aad-105">Questa esercitazione consente di esplorare le funzionalità di C# 7.0 in modo interattivo, usando il browser per scrivere codice C# e visualizzare i risultati della compilazione e dell'esecuzione del codice.</span><span class="sxs-lookup"><span data-stu-id="f9aad-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="f9aad-106">L'esercitazione contiene una serie di lezioni che modificano le procedure C# precedenti, in modo da usare le nuove funzionalità, più concise, del linguaggio C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="f9aad-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="f9aad-107">Il resto di questo articolo offre una panoramica di ognuna di queste funzionalità, con un collegamento per esplorare ciascuna di esse più in dettaglio.</span><span class="sxs-lookup"><span data-stu-id="f9aad-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="f9aad-108">Dichiarazioni di variabili out nella posizione di assegnazione</span><span class="sxs-lookup"><span data-stu-id="f9aad-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f9aad-109\">La sintassi esistente che supporta i parametri `out` è stata migliorata in questa versione.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"f9aad-110\">Scegliere il pulsante *Attiva la modalità messa a fuoco* nella parte inferiore della pagina, quindi provare il codice seguente nella finestra interattiva:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"f9aad-111\">Ora è possibile dichiarare variabili `out` nell'elenco di argomenti di una chiamata al metodo, anziché scrivere un'istruzione di dichiarazione separata.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"f9aad-112\">È possibile spostare la dichiarazione nella chiamata al metodo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"f9aad-113\">Aggiungere il codice seguente nella parte inferiore della finestra interattiva:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"f9aad-114\">È possibile convertire la dichiarazione `int` in una dichiarazione `var`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"f9aad-115\">Aggiungere il codice seguente alla finestra interattiva:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"f9aad-116\">La nuova sintassi offre due vantaggi importanti rispetto alla sintassi esistente:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"f9aad-117\">Il codice è più facile da leggere.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"f9aad-118\">Si dichiara la variabile out nel punto in cui viene usata, non in una riga precedente.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"f9aad-119\">Non è necessario assegnare un valore iniziale.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"f9aad-120\">Dichiarando la variabile `out` nel punto in cui viene usata in una chiamata al metodo, non è possibile usarla accidentalmente prima che venga assegnata.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"f9aad-121\">L'ambito della variabile dichiarata è quello che include l'istruzione `if`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"f9aad-122\">In questo modo è possibile usare la variabile in un secondo momento.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"f9aad-123\">Modificare l'ultimo blocco `if` come illustrato nel frammento di codice seguente.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="f9aad-124">Le tuple creano strutture dei dati leggere</span><span class="sxs-lookup"><span data-stu-id="f9aad-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"f9aad-125\">Le tuple sono strutture di dati leggere che contengono più campi per rappresentare i membri dati.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"f9aad-126\">I campi non vengono convalidati e non è possibile definire metodi personalizzati.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"f9aad-127\">Le tuple erano già disponibili prima di C# 7.0, ma in modo poco efficiente e senza supporto del linguaggio.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"f9aad-128\">Questo significava poter fare riferimento agli elementi delle tuple solo come `Item1`, `Item2` e così via.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"f9aad-129\">C# 7.0 introduce il supporto del linguaggio per le tuple, che consente nomi semantici per i campi di una tupla con tipi di tupla nuovi e più efficienti.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"f9aad-130\">È possibile creare una tupla assegnando un valore a ogni membro con nome:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"f9aad-131\">La tupla `namedLetters` contiene campi detti `Alpha` e `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"f9aad-132\">Tali nomi esistono solo in fase di compilazione e non vengono mantenuti in fase di runtime, ad esempio quando si esamina la tupla tramite reflection.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"f9aad-133\">In un'assegnazione di tupla è anche possibile specificare i nomi dei campi sul lato destro dell'assegnazione:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"f9aad-134\">È possibile specificare nomi per i campi sia a sinistra che a destra dell'assegnazione, ma i nomi sul lato destro vengono ignorati.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"f9aad-135\">Le tuple sono particolarmente utili come tipi restituiti per i metodi `private` e `internal`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"f9aad-136\">Le tuple offrono una sintassi semplice per consentire a tali metodi di restituire più valori distinti.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"f9aad-137\">La creazione di una tupla è più efficiente e più produttiva rispetto alla creazione di una classe o struct.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"f9aad-138\">La tupla ha una sintassi più semplice e leggera per definire una struttura dei dati che contiene più di un valore.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"f9aad-139\">Il metodo di esempio riportato di seguito restituisce i valori minimo e massimo trovati in una sequenza di interi:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-139\">The example method below returns the minimum and maximum values found in a sequence of integers:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"f9aad-140\">Può rendersi necessario decomprimere i membri di una tupla che sono stati restituiti da un metodo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-140\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"f9aad-141\">In questo caso è possibile dichiarare variabili separate per ogni valore nella tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-141\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"f9aad-142\">Questa operazione è detta *decostruzione* della tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-142\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"f9aad-143\">Aggiungere il codice seguente nel browser per provare il funzionamento:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-143\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"f9aad-144\">Quando si lavora con le tuple spesso si rileverà che non vengono usati tutti i membri di un risultato della tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-144\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"f9aad-145\">In questi casi è possibile rimuovere uno o più valori restituiti usando `_` al posto di una variabile.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-145\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"f9aad-146\">Aggiungere il codice seguente nel browser per provare il funzionamento:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-146\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"f9aad-147\">Informazioni più approfondite sulle tuple sono disponibili nell'[articolo relativo alle tuple](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-147\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"f9aad-148\">Altre informazioni sulle variabili discard sono disponibili nell'[articolo sulle variabili discard](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-148\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="f9aad-149">Usare il criterio del tipo con l'espressione is</span><span class="sxs-lookup"><span data-stu-id="f9aad-149">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="f9aad-150">L'espressione con criterio `is` estende il noto [operatore `is`](../../language-reference/keywords/is.md#pattern-matching-with-is) per l'esecuzione di query su un oggetto oltre il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="f9aad-150">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="f9aad-151">Provare il codice seguente nella finestra del browser:</span><span class="sxs-lookup"><span data-stu-id="f9aad-151">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="f9aad-152">Convertire la dichiarazione della variabile in una stringa:</span><span class="sxs-lookup"><span data-stu-id="f9aad-152">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="f9aad-153">Ora l'espressione `is` è false, pertanto viene eseguito il ramo `else`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-153">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="f9aad-154">Provare a sostituire `count` con `number` nel ramo else:</span><span class="sxs-lookup"><span data-stu-id="f9aad-154">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="f9aad-155">Il codice precedente non viene compilato, perché `number` non è assegnato nel ramo `else`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-155">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="f9aad-156">È assegnato solo nel ramo `true` dell'istruzione `if`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-156">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="f9aad-157">Il criterio del tipo espressione `is` è utile quando il numero di tipi da sottoporre a test è ridotto.</span><span class="sxs-lookup"><span data-stu-id="f9aad-157">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="f9aad-158">Spesso è invece necessario eseguire il test di molti tipi.</span><span class="sxs-lookup"><span data-stu-id="f9aad-158">Often, you may need to test multiple types.</span></span> <span data-ttu-id="f9aad-159">In tal caso è necessaria l'istruzione dei criteri di ricerca `switch`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-159">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="f9aad-160">Criteri di ricerca nell'istruzione switch</span><span class="sxs-lookup"><span data-stu-id="f9aad-160">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="f9aad-161">L'*espressione di ricerca* ha una sintassi familiare, basata sull'istruzione `switch` che fa già parte del linguaggio C#.</span><span class="sxs-lookup"><span data-stu-id="f9aad-161">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="f9aad-162">Per iniziare si consideri un piccolo campione basato sulla sintassi dell'espressione `is` esaminata nella pagina precedente:</span><span class="sxs-lookup"><span data-stu-id="f9aad-162">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="f9aad-163">Il codice precedente cerca un elemento `int` o `null`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-163">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="f9aad-164">Tutti gli altri tipi hanno raggiunto il case predefinito.</span><span class="sxs-lookup"><span data-stu-id="f9aad-164">Every other type reached the default case.</span></span> <span data-ttu-id="f9aad-165">Aggiungere le due righe seguenti per verificare il comportamento:</span><span class="sxs-lookup"><span data-stu-id="f9aad-165">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="f9aad-166">L'espressione `switch` converte un tipo nullable nel tipo corrispondente.</span><span class="sxs-lookup"><span data-stu-id="f9aad-166">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="f9aad-167">Aggiungere quanto segue per la verifica:</span><span class="sxs-lookup"><span data-stu-id="f9aad-167">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="f9aad-168">È possibile aggiungere un numero qualsiasi di altre espressioni di criterio del tipo alle istruzioni switch.</span><span class="sxs-lookup"><span data-stu-id="f9aad-168">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="f9aad-169">Aggiungere quanto segue prima del case `null`:</span><span class="sxs-lookup"><span data-stu-id="f9aad-169">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="f9aad-170">Assicurarsi che questi elementi funzionino aggiungendo i test seguenti:</span><span class="sxs-lookup"><span data-stu-id="f9aad-170">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="f9aad-171">Le espressioni di ricerca supportano anche le costanti.</span><span class="sxs-lookup"><span data-stu-id="f9aad-171">The match expressions also support constants.</span></span> <span data-ttu-id="f9aad-172">Ciò consente di risparmiare tempo eseguendo il factoring dei casi semplici:</span><span class="sxs-lookup"><span data-stu-id="f9aad-172">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="f9aad-173">È necessario aggiungere il case precedente *prima* dell'espressione `case int:`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-173">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="f9aad-174">Se lo si aggiunge dopo tale case, il compilatore segnala che è già stato gestito da un case precedente.</span><span class="sxs-lookup"><span data-stu-id="f9aad-174">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="f9aad-175">È possibile aggiungere una clausola `when` a qualsiasi case di criterio per eseguire il test di altre condizioni oltre a un tipo o a un valore di costante.</span><span class="sxs-lookup"><span data-stu-id="f9aad-175">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="f9aad-176">Provare aggiungendo il case seguente sopra il case `string` generale:</span><span class="sxs-lookup"><span data-stu-id="f9aad-176">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="f9aad-177">Eseguire quindi il test con codice simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="f9aad-177">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="f9aad-178">La nuova sintassi per le espressioni di criteri di ricerca, più chiara e concisa, semplifica la creazione degli algoritmi di invio sulla base del tipo di un oggetto o di altre proprietà.</span><span class="sxs-lookup"><span data-stu-id="f9aad-178">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="f9aad-179">Le espressioni di criteri di ricerca abilitano questi costrutti per i tipi di dati non correlati per ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="f9aad-179">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="f9aad-180">Altre informazioni sui criteri di ricerca sono disponibili nell'articolo dedicato ai [criteri di ricerca in C#](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="f9aad-180">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="f9aad-181">Ottimizzare l'archiviazione in memoria usando variabili locali e valori restituiti per riferimento</span><span class="sxs-lookup"><span data-stu-id="f9aad-181">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="f9aad-182">Questa funzionalità abilita algoritmi che usano e restituiscono riferimenti a variabili definite altrove.</span><span class="sxs-lookup"><span data-stu-id="f9aad-182">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="f9aad-183">Un esempio è la gestione di matrici di grandi dimensioni e la definizione di un'unica posizione con determinate caratteristiche.</span><span class="sxs-lookup"><span data-stu-id="f9aad-183">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="f9aad-184">Un metodo restituirebbe due indici per una singola posizione nella matrice:</span><span class="sxs-lookup"><span data-stu-id="f9aad-184">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="f9aad-185">Per eseguire il test del metodo usare il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="f9aad-185">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="f9aad-186">Questo metodo `Find` restituisce gli indici all'elemento nella matrice.</span><span class="sxs-lookup"><span data-stu-id="f9aad-186">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="f9aad-187">Ciò induce i chiamanti a scrivere codice che usa tali indici per dereferenziare la matrice e modificare un singolo elemento.</span><span class="sxs-lookup"><span data-stu-id="f9aad-187">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="f9aad-188">È più opportuno scrivere un metodo che restituisce un *riferimento* all'elemento della matrice che si vuole modificare.</span><span class="sxs-lookup"><span data-stu-id="f9aad-188">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="f9aad-189">Verrà ora analizzata una serie di modifiche per illustrare la funzionalità delle variabili locali ref e la procedura di creazione di un metodo che restituisce un riferimento all'archiviazione interna.</span><span class="sxs-lookup"><span data-stu-id="f9aad-189">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="f9aad-190">Si apprenderanno anche le regole per i valori restituiti ref e le variabili locali ref che consentono di evitare usi impropri della funzionalità.</span><span class="sxs-lookup"><span data-stu-id="f9aad-190">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="f9aad-191">Iniziare modificando la dichiarazione di metodo `Find` in modo che restituisca un oggetto `ref int` anziché una tupla.</span><span class="sxs-lookup"><span data-stu-id="f9aad-191">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="f9aad-192">Modificare l'istruzione return in modo che restituisca l'elemento in corrispondenza degli indici corretti:</span><span class="sxs-lookup"><span data-stu-id="f9aad-192">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="f9aad-193">Modificare il valore restituito finale in modo da generare un'eccezione:</span><span class="sxs-lookup"><span data-stu-id="f9aad-193">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="f9aad-194">Si noti che questo codice non verrà compilato.</span><span class="sxs-lookup"><span data-stu-id="f9aad-194">Note that this won't compile.</span></span> <span data-ttu-id="f9aad-195">La dichiarazione del metodo indica un valore restituito `ref`, ma l'istruzione return specifica un valore restituito value.</span><span class="sxs-lookup"><span data-stu-id="f9aad-195">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="f9aad-196">È necessario aggiungere la parola chiave `ref` a ogni istruzione return.</span><span class="sxs-lookup"><span data-stu-id="f9aad-196">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="f9aad-197">Ciò indica la restituzione per riferimento e consente agli sviluppatori che leggono il codice di ricordare in seguito che il metodo restituisce per riferimento:</span><span class="sxs-lookup"><span data-stu-id="f9aad-197">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="f9aad-198">Ora che il metodo restituisce un riferimento al valore integer della matrice, è necessario modificare il punto in cui viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="f9aad-198">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="f9aad-199">La dichiarazione `var` significa che `valItem` è ora un oggetto `int` anziché una tupla.</span><span class="sxs-lookup"><span data-stu-id="f9aad-199">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="f9aad-200">Modificare il codice chiamante come segue:</span><span class="sxs-lookup"><span data-stu-id="f9aad-200">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="f9aad-201">La seconda istruzione `WriteLine` nell'esempio precedente stampa il valore `42`, non `24`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-201">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="f9aad-202">La variabile `valItem` è `int`, non `ref int`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-202">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="f9aad-203">La parola chiave `var` consente al compilatore di specificare il tipo, ma non aggiunge in modo implicito il modificatore `ref`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-203">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="f9aad-204">Il valore a cui fa riferimento `ref return` viene invece *copiato* nella variabile sul lato sinistro dell'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="f9aad-204">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="f9aad-205">La variabile non è una variabile locale `ref`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-205">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="f9aad-206">Per modificare il riferimento restituito è necessario aggiungere il modificatore `ref` alla dichiarazione di variabile locale e prima della chiamata di `Find`, per fare in modo che la variabile sia un riferimento quando il valore restituito è un riferimento.</span><span class="sxs-lookup"><span data-stu-id="f9aad-206">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="f9aad-207">Modificare il codice di test nel browser per farlo corrispondere a quanto segue:</span><span class="sxs-lookup"><span data-stu-id="f9aad-207">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="f9aad-208">Ora la seconda istruzione `WriteLine` nell'esempio precedente produce il valore `24`, a indicare che la memorizzazione nella matrice è stata modificata.</span><span class="sxs-lookup"><span data-stu-id="f9aad-208">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="f9aad-209">La variabile locale è stata dichiarata con il modificatore `ref` e accetterà un valore restituito `ref`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-209">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="f9aad-210">È necessario inizializzare una variabile `ref` quando viene dichiarata. Non è possibile separare la dichiarazione e l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="f9aad-210">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="f9aad-211">Il linguaggio C# usa altre tre regole per evitare usi impropri delle variabili locali e dei valori restituiti `ref`:</span><span class="sxs-lookup"><span data-stu-id="f9aad-211">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="f9aad-212">Non è possibile assegnare un valore restituito del metodo standard a una variabile locale `ref`.</span><span class="sxs-lookup"><span data-stu-id="f9aad-212">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="f9aad-213">Non è possibile restituire un oggetto `ref` a una variabile la cui durata non si estende oltre l'esecuzione del metodo.</span><span class="sxs-lookup"><span data-stu-id="f9aad-213">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="f9aad-214">Non è possibile usare variabili locali e valori restituiti `ref` con i metodi asincroni.</span><span class="sxs-lookup"><span data-stu-id="f9aad-214">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="f9aad-215">L'aggiunta di variabili locali e valori restituiti ref abilita algoritmi più efficienti, evitando la copia dei valori o l'esecuzione ripetuta di operazioni di dereferenziazione.</span><span class="sxs-lookup"><span data-stu-id="f9aad-215">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="f9aad-216">Per altre informazioni, vedere l'articolo relativo alla [parola chiave ref](../../language-reference/keywords/ref.md).</span><span class="sxs-lookup"><span data-stu-id="f9aad-216">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="f9aad-217">Ridurre al minimo l'accesso al codice con le funzioni locali</span><span class="sxs-lookup"><span data-stu-id="f9aad-217">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"f9aad-218\">Ora è possibile dichiarare funzioni locali annidate in altre funzioni.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-218\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"f9aad-219\">In questo modo è possibile ridurre al minimo la visibilità di queste funzioni.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-219\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"f9aad-220\">Esistono tre casi d'uso ovvi per le funzioni locali:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-220\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"f9aad-221\">Funzioni ricorsive.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-221\">Recursive functions.</span></span>\n- <span data-ttu-id=\"f9aad-222\">Metodi iterator.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-222\">Iterator methods.</span></span>\n- <span data-ttu-id=\"f9aad-223\">Metodi asincroni.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-223\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"f9aad-224\">Si inizierà con i metodi ricorsivi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-224\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"f9aad-225\">Provare il codice seguente nel browser per calcolare `6!` (fattoriale):</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-225\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"f9aad-226\">Le funzioni locali sono un ottimo modo per implementare gli algoritmi ricorsivi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-226\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"f9aad-227\">Altri usi comuni sono i metodi iterator pubblici e i metodi async pubblici.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-227\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"f9aad-228\">Entrambi i tipi di metodi generano codice che segnala gli errori in ritardo rispetto a quanto previsto dai programmatori.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-228\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"f9aad-229\">Nel caso dei metodi iterator tutte le eccezioni vengono riscontrate solo quando si chiama il codice che enumera la sequenza restituita.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-229\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"f9aad-230\">Nel caso dei metodi async tutte le eccezioni vengono riscontrate solo quando è atteso l'oggetto restituito `Task`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-230\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"f9aad-231\">I metodi iterator sono più semplici da esplorare nel browser, pertanto ora si useranno questi metodi per l'esplorazione.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-231\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"f9aad-232\">Provare a eseguire il codice seguente, che chiama un metodo iterator nel browser:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-232\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"f9aad-233\">Eseguire il codice.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-233\">Run the code.</span></span> <span data-ttu-id=\"f9aad-234\">Osservare che l'eccezione viene generata quando il codice inizia l'iterazione del secondo set di risultati.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-234\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"f9aad-235\">Il codice che esegue l'iterazione del primo set di risultati è già stato eseguito.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-235\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"f9aad-236\">Questo esempio è di dimensioni ridotte e non cambia le strutture di dati, pertanto è innocuo e facile da correggere.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-236\">This sample is both small and doesn't change any data structures, dso it's harmless and easy to fix.</span></span> <span data-ttu-id=\"f9aad-237\">Tuttavia, in un programma più grande in cui i due oggetti iterator potrebbero essere creati in metodi figlio diversi, può risultare difficile trovare la causa radice.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-237\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"f9aad-238\">Se il primo metodo iterator ha modificato lo stato dei dati, può verificarsi anche il danneggiamento dei dati.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-238\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"f9aad-239\">È preferibile che l'eccezione venga generata immediatamente, prima dell'esecuzione di qualsiasi operazione.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-239\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"f9aad-240\">È possibile eseguire il refactoring del codice in modo che il metodo pubblico convalidi tutti gli argomenti e una funzione locale esegua l'enumerazione:</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-240\">You can refactor the code so that the public method validates all arguments, and a local function that performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"f9aad-241\">La versione precedente indica chiaramente che viene fatto riferimento al metodo locale solo nel contesto del metodo esterno.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-241\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"f9aad-242\">Le regole per le funzioni locali garantiscono inoltre che uno sviluppatore non possa chiamare accidentalmente la funzione locale da un'altra posizione nella classe accidentalmente e ignorare la convalida degli argomenti.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-242\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"f9aad-243\">La stessa tecnica può essere usata con i metodi `async` per garantire che le eccezioni risultanti dalla convalida degli argomenti vengano generate prima che inizino le attività asincrone.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-243\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"f9aad-244\">Alcune delle progettazioni supportate dalle funzioni locali possono essere eseguite anche usando le *espressioni lambda*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-244\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"f9aad-245\">Per chi è interessato sono disponibili [altre informazioni sulle differenze](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"f9aad-245\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="f9aad-246">L'esplorazione delle nuove funzionalità principali di C# 7 è stata completata.</span><span class="sxs-lookup"><span data-stu-id="f9aad-246">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="f9aad-247">È ora possibile provare tali funzionalità autonomamente nelle proprie applicazioni.</span><span class="sxs-lookup"><span data-stu-id="f9aad-247">Now try them yourself in your applications.</span></span> <span data-ttu-id="f9aad-248">È possibile visualizzare l'elenco completo nell'articolo sulle [novità di C# 7](../../whats-new/csharp-7.md).</span><span class="sxs-lookup"><span data-stu-id="f9aad-248">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
