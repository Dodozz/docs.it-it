---
title: Controllo delle versioni con le parole chiave Override e New - Guida per programmatori C#
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: ec6040081d44a389bd42bb50cdd81ac0634abf91
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/28/2019
ms.locfileid: "64583118"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="08377-102">Controllo delle versioni con le parole chiave Override e New (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="08377-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="08377-103">Il linguaggio C# è progettato in modo che il controllo delle versioni tra le classi [di base](../../../csharp/language-reference/keywords/base.md) e le classi derivate in diverse librerie possa svilupparsi e mantenere la compatibilità con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="08377-103">The C# language is designed so that versioning between [base](../../../csharp/language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="08377-104">Ciò significa ad esempio che l'introduzione di un nuovo membro in una classe [di base](../../../csharp/language-reference/keywords/class.md) con lo stesso nome di un membro in una classe derivata è completamente supportata da C# e non causa comportamenti imprevisti.</span><span class="sxs-lookup"><span data-stu-id="08377-104">This means, for example, that the introduction of a new member in a base [class](../../../csharp/language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="08377-105">Significa inoltre che una classe deve dichiarare in modo esplicito se un metodo deve eseguire l'override di un metodo ereditato o se si tratta di un nuovo metodo che consente di nascondere un metodo ereditato con nome simile.</span><span class="sxs-lookup"><span data-stu-id="08377-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="08377-106">In C# le classi derivate possono contenere metodi con lo stesso nome dei metodi delle classi di base.</span><span class="sxs-lookup"><span data-stu-id="08377-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
- <span data-ttu-id="08377-107">Il metodo della classe di base deve essere definito come [virtuale](../../../csharp/language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="08377-107">The base class method must be defined [virtual](../../../csharp/language-reference/keywords/virtual.md).</span></span>  
  
- <span data-ttu-id="08377-108">Se il metodo della classe derivata non è preceduto dalle parole chiave [new](../../../csharp/language-reference/keywords/new.md) o [override](../../../csharp/language-reference/keywords/override.md), il compilatore genera un avviso e il metodo si comporta come se fosse presente la parola chiave `new`.</span><span class="sxs-lookup"><span data-stu-id="08377-108">If the method in the derived class is not preceded by [new](../../../csharp/language-reference/keywords/new.md) or [override](../../../csharp/language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
- <span data-ttu-id="08377-109">Se il metodo della classe derivata è preceduto dalla parola chiave `new`, il metodo è definito come indipendente dal metodo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="08377-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
- <span data-ttu-id="08377-110">Se il metodo della classe derivata è preceduto dalla parola chiave `override`, gli oggetti della classe derivata chiameranno tale metodo anziché il metodo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="08377-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
- <span data-ttu-id="08377-111">Il metodo della classe di base può essere chiamato dall'interno della classe derivata usando la parola chiave `base`.</span><span class="sxs-lookup"><span data-stu-id="08377-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
- <span data-ttu-id="08377-112">Le parole chiave `override`, `virtual` e `new` possono essere applicate anche a proprietà, indicizzatori ed eventi.</span><span class="sxs-lookup"><span data-stu-id="08377-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="08377-113">Per impostazione predefinita, i metodi C# non sono virtuali.</span><span class="sxs-lookup"><span data-stu-id="08377-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="08377-114">Se un metodo viene dichiarato come virtuale, qualsiasi classe che eredita il metodo può implementare la propria versione.</span><span class="sxs-lookup"><span data-stu-id="08377-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="08377-115">Per rendere un metodo virtuale, si usa il modificatore `virtual` nella dichiarazione del metodo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="08377-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="08377-116">La classe derivata può quindi eseguire l'override del metodo di base virtuale usando la parola chiave `override` oppure nascondere il metodo virtuale nella classe di base usando la parola chiave `new`.</span><span class="sxs-lookup"><span data-stu-id="08377-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="08377-117">Se non si specifica né la parola chiave `override` né la parola chiave `new`, il compilatore genera un avviso e il metodo della classe derivata nasconde il metodo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="08377-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="08377-118">Per dimostrare questo concetto in pratica, si supponga che la società A abbia creato una classe denominata `GraphicsClass` che viene usata dal programma.</span><span class="sxs-lookup"><span data-stu-id="08377-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="08377-119">Di seguito è illustrata la classe `GraphicsClass`:</span><span class="sxs-lookup"><span data-stu-id="08377-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#27)]  
  
 <span data-ttu-id="08377-120">La società usa questa classe e l'utente la usa per derivare la propria classe, aggiungendo un nuovo metodo:</span><span class="sxs-lookup"><span data-stu-id="08377-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#28)]  
  
 <span data-ttu-id="08377-121">L'applicazione viene eseguita senza problemi, finché la società A rilascia una nuova versione di `GraphicsClass`, simile al codice seguente:</span><span class="sxs-lookup"><span data-stu-id="08377-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#29)]  
  
 <span data-ttu-id="08377-122">La nuova versione di `GraphicsClass` ora contiene un metodo denominato `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="08377-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="08377-123">Inizialmente non accade nulla.</span><span class="sxs-lookup"><span data-stu-id="08377-123">Initially, nothing occurs.</span></span> <span data-ttu-id="08377-124">La nuova versione è ancora compatibile a livello binario con la versione precedente.</span><span class="sxs-lookup"><span data-stu-id="08377-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="08377-125">Qualsiasi software già distribuito continuerà a funzionare, anche se la nuova classe viene installata nei relativi computer.</span><span class="sxs-lookup"><span data-stu-id="08377-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="08377-126">Le eventuali chiamate al metodo `DrawRectangle` continueranno a fare riferimento alla versione in uso nella classe derivata.</span><span class="sxs-lookup"><span data-stu-id="08377-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="08377-127">Tuttavia, non appena l'applicazione viene ricompilata usando la nuova versione di `GraphicsClass`, si riceve un avviso del compilatore, CS0108.</span><span class="sxs-lookup"><span data-stu-id="08377-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="08377-128">L'avviso informa che è necessario stabilire in che modo dovrà funzionare il metodo `DrawRectangle` nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="08377-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="08377-129">Se il metodo deve eseguire l'override del nuovo metodo della classe di base, usare la parola chiave `override`:</span><span class="sxs-lookup"><span data-stu-id="08377-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#30)]  
  
 <span data-ttu-id="08377-130">La parola chiave `override` garantisce che qualsiasi oggetto derivato da `YourDerivedGraphicsClass` userà la versione della classe derivata di `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="08377-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="08377-131">Gli oggetti derivati da `YourDerivedGraphicsClass` possono comunque accedere alla versione della classe di base `DrawRectangle` usando la parola chiave di base:</span><span class="sxs-lookup"><span data-stu-id="08377-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#44)]  
  
 <span data-ttu-id="08377-132">Se si preferisce che il metodo non esegua l'override del nuovo metodo della classe di base, attenersi alle indicazioni che seguono.</span><span class="sxs-lookup"><span data-stu-id="08377-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="08377-133">Per evitare confusione tra i due metodi, è possibile rinominare il metodo da usare.</span><span class="sxs-lookup"><span data-stu-id="08377-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="08377-134">Questa operazione può richiedere molto tempo e causare errori e in alcuni casi è poco pratica.</span><span class="sxs-lookup"><span data-stu-id="08377-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="08377-135">Tuttavia, se il progetto è relativamente piccolo, è possibile usare le opzioni di refactoring di Visual Studio per rinominare il metodo.</span><span class="sxs-lookup"><span data-stu-id="08377-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="08377-136">Per altre informazioni, vedere [Refactoring di classi e tipi (Progettazione classi)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span><span class="sxs-lookup"><span data-stu-id="08377-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer).</span></span>  
  
 <span data-ttu-id="08377-137">In alternativa, è possibile evitare l'avviso usando la parola chiave `new` nella definizione della classe derivata:</span><span class="sxs-lookup"><span data-stu-id="08377-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#31)]  
  
 <span data-ttu-id="08377-138">L'uso della parola chiave `new` indica al compilatore che la definizione nasconde la definizione contenuta nella classe di base.</span><span class="sxs-lookup"><span data-stu-id="08377-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="08377-139">Comportamento predefinito.</span><span class="sxs-lookup"><span data-stu-id="08377-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="08377-140">Override e selezione del metodo</span><span class="sxs-lookup"><span data-stu-id="08377-140">Override and Method Selection</span></span>  
 <span data-ttu-id="08377-141">Quando un metodo è denominato in una classe, il compilatore C# seleziona il metodo migliore per la chiamata se più metodi sono compatibili con la chiamata, ad esempio quando esistono due metodi con lo stesso nome e parametri compatibili con il parametro passato.</span><span class="sxs-lookup"><span data-stu-id="08377-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="08377-142">I seguenti metodi sarebbero compatibili:</span><span class="sxs-lookup"><span data-stu-id="08377-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#32)]  
  
 <span data-ttu-id="08377-143">Quando si chiama `DoWork` per un'istanza di `Derived`, il compilatore C# tenta per prima cosa di rendere la chiamata compatibile con le versioni di `DoWork` originariamente dichiarate in `Derived`.</span><span class="sxs-lookup"><span data-stu-id="08377-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="08377-144">I metodi di override non vengono considerati come dichiarati per una classe, sono nuove implementazioni di un metodo dichiarato per una classe di base.</span><span class="sxs-lookup"><span data-stu-id="08377-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="08377-145">Solo se il compilatore C# non è in grado di associare la chiamata al metodo a un metodo originale in `Derived`, tenterà di associare la chiamata a un metodo sottoposto a override con lo stesso nome e parametri compatibili.</span><span class="sxs-lookup"><span data-stu-id="08377-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="08377-146">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="08377-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#33)]  
  
 <span data-ttu-id="08377-147">Poiché la variabile `val` può essere convertita in un valore double in modo implicito, il compilatore C# chiama `DoWork(double)` anziché `DoWork(int)`.</span><span class="sxs-lookup"><span data-stu-id="08377-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="08377-148">Questa situazione può essere evitata in due modi.</span><span class="sxs-lookup"><span data-stu-id="08377-148">There are two ways to avoid this.</span></span> <span data-ttu-id="08377-149">Primo, evitare di dichiarare i nuovi metodi con lo stesso nome dei metodi virtuali.</span><span class="sxs-lookup"><span data-stu-id="08377-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="08377-150">Secondo, è possibile indicare al compilatore C# di chiamare il metodo virtuale facendo in modo che esegua una ricerca nell'elenco dei metodi della classe di base eseguendo il cast dell'istanza di `Derived` a `Base`.</span><span class="sxs-lookup"><span data-stu-id="08377-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="08377-151">Poiché il metodo è virtuale, verrà chiamata l'implementazione di `DoWork(int)` per `Derived`.</span><span class="sxs-lookup"><span data-stu-id="08377-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="08377-152">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="08377-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#34)]  
  
 <span data-ttu-id="08377-153">Per altri esempi di `new` e `override`, vedere [Sapere quando usare le parole chiave Override e New](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="08377-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="08377-154">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="08377-154">See also</span></span>

- [<span data-ttu-id="08377-155">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="08377-155">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="08377-156">Classi e struct</span><span class="sxs-lookup"><span data-stu-id="08377-156">Classes and Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/index.md)
- [<span data-ttu-id="08377-157">Metodi</span><span class="sxs-lookup"><span data-stu-id="08377-157">Methods</span></span>](../../../csharp/programming-guide/classes-and-structs/methods.md)
- [<span data-ttu-id="08377-158">Ereditarietà</span><span class="sxs-lookup"><span data-stu-id="08377-158">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
