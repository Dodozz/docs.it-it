---
title: Passaggi nel flusso di lavoro DevOps ciclo esterno per un'applicazione Docker
description: Informazioni sulla procedura per il ciclo"esterno" del flusso di lavoro DevOps
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 02/15/2019
ms.openlocfilehash: 7043f34557651c3e8e79baf263bd0bcefd5a847a
ms.sourcegitcommit: bd28ff1e312eaba9718c4f7ea272c2d4781a7cac
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/26/2019
ms.locfileid: "56836409"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="a9e07-103">Passaggi nel flusso di lavoro DevOps ciclo esterno per un'applicazione Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="a9e07-104">Figura 5-1 presenta una descrizione di end-to-end dei passaggi che comprendono il flusso di lavoro DevOps ciclo esterno.</span><span class="sxs-lookup"><span data-stu-id="a9e07-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![Questo diagramma mostra il ciclo"esterno" della metodologia DevOps.](./media/image1.png)

<span data-ttu-id="a9e07-108">**Figura 5-1**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-108">**Figure 5-1**.</span></span> <span data-ttu-id="a9e07-109">Flusso di lavoro ciclo esterno DevOps per le applicazioni Docker con strumenti Microsoft</span><span class="sxs-lookup"><span data-stu-id="a9e07-109">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="a9e07-110">A questo punto, verrà ora esaminato ognuno di questi passaggi in maggiore dettaglio.</span><span class="sxs-lookup"><span data-stu-id="a9e07-110">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="a9e07-111">Passaggio 1: Flusso di lavoro di sviluppo a ciclo interno</span><span class="sxs-lookup"><span data-stu-id="a9e07-111">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="a9e07-112">Questo passaggio è illustrato in dettaglio nel capitolo 4, ma, per ricapitolare, ecco dove inizia il ciclo esterno, dal momento in cui uno sviluppatore effettua il push di codice per il sistema di gestione di controllo di origine (ad esempio Git) che ha avviato le azioni della pipeline di integrazione continua.</span><span class="sxs-lookup"><span data-stu-id="a9e07-112">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="a9e07-113">Passaggio 2: Integrazione del controllo del codice sorgente e gestione dei servizi di Azure DevOps e Git</span><span class="sxs-lookup"><span data-stu-id="a9e07-113">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="a9e07-114">A questo punto, è necessario disporre di un sistema di controllo della versione per raccogliere una versione codificata di tutto il codice proveniente da diversi sviluppatori del team.</span><span class="sxs-lookup"><span data-stu-id="a9e07-114">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="a9e07-115">Anche se può sembrare abitudine a maggior parte degli sviluppatori, durante la creazione di applicazioni Docker in un ciclo di vita di DevOps del ciclo di controllo del codice sorgente (SCC) e la gestione del codice sorgente, è essenziale sottolineare che non è necessario inviare le immagini Docker con l'applicazione direttamente per il global Docker del Registro di sistema (ad esempio registro contenitori di Azure o Hub Docker) dal computer dello sviluppatore.</span><span class="sxs-lookup"><span data-stu-id="a9e07-115">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="a9e07-116">Al contrario, le immagini Docker venga rilasciato e distribuiti in ambienti di produzione devono essere create esclusivamente sul codice sorgente che viene integrato nella compilazione globale o della pipeline di integrazione continua basata su repository del codice sorgente (ad esempio Git).</span><span class="sxs-lookup"><span data-stu-id="a9e07-116">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="a9e07-117">Le immagini locali, generate dagli sviluppatori, devono solo essere usate da essi durante il test entro le proprie macchine.</span><span class="sxs-lookup"><span data-stu-id="a9e07-117">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="a9e07-118">Ecco perché è fondamentale per avere la pipeline di DevOps attivata dal codice di controllo del codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="a9e07-118">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="a9e07-119">Azure DevOps Services e Team Foundation Server supporta Git e Team Foundation Version Control.</span><span class="sxs-lookup"><span data-stu-id="a9e07-119">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="a9e07-120">È possibile scegliere tra di essi e usarlo per un'esperienza di Microsoft end-to-end.</span><span class="sxs-lookup"><span data-stu-id="a9e07-120">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="a9e07-121">Tuttavia, è anche possibile gestire il codice in repository esterni (ad esempio, GitHub, i repository Git locale o Subversion) e ancora essere in grado di connettersi alla cache e ottenere il codice come punto di partenza per la pipeline di integrazione continua di DevOps.</span><span class="sxs-lookup"><span data-stu-id="a9e07-121">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="a9e07-122">Passaggio 3: Compilare, integrazione continua, integrare e testare con DevOps di Azure i servizi e Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-122">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="a9e07-123">Integrazione continua è emersa come standard per la distribuzione e test del software moderno.</span><span class="sxs-lookup"><span data-stu-id="a9e07-123">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="a9e07-124">La soluzione di Docker mantiene una netta separazione delle problematiche tra i team di sviluppo e operazioni.</span><span class="sxs-lookup"><span data-stu-id="a9e07-124">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="a9e07-125">Immutabilità delle immagini Docker assicura una distribuzione ripetibile tra ciò che ha sviluppato, testato con integrazione continua ed eseguire nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-125">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="a9e07-126">Motore docker distribuito tra i computer portatili per gli sviluppatori e infrastruttura di test rende i contenitori portatile per gli ambienti.</span><span class="sxs-lookup"><span data-stu-id="a9e07-126">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="a9e07-127">A questo punto, dopo aver creato un sistema di controllo della versione con il codice corretto invio, è necessario un *servizio di compilazione* per prelevare il codice ed eseguire la compilazione globali e i test.</span><span class="sxs-lookup"><span data-stu-id="a9e07-127">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="a9e07-128">Il flusso di lavoro interno per questo passaggio (CI, compilazione, test) riguarda la costruzione di una pipeline di integrazione continua costituita nel repository del codice (Git, e così via), il server di compilazione (servizi di Azure DevOps), il motore Docker e un registro Docker.</span><span class="sxs-lookup"><span data-stu-id="a9e07-128">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="a9e07-129">È possibile utilizzare servizi di Azure DevOps come base per la creazione delle applicazioni e impostare la pipeline di integrazione continua e per la pubblicazione di "elementi" compilati da un "repository di elementi," come illustrato nel passaggio successivo.</span><span class="sxs-lookup"><span data-stu-id="a9e07-129">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="a9e07-130">Quando si usa Docker per la distribuzione, gli elementi"finale" per la distribuzione delle immagini Docker con l'applicazione o i servizi incorporate in esse contenute.</span><span class="sxs-lookup"><span data-stu-id="a9e07-130">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="a9e07-131">Queste immagini vengono effettuato il push o pubblicate in un *registro Docker* (vale a dire un repository privato, ad esempio quelli in Registro contenitori di Azure è possibile avere o una pubblica, ad esempio del Registro di sistema dell'Hub Docker, che viene usato comunemente per le immagini ufficiali di base).</span><span class="sxs-lookup"><span data-stu-id="a9e07-131">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="a9e07-132">Ecco il concetto di base: La pipeline CI sarà avviata approvazione da un commit a un repository di controllo del codice sorgente come Git.</span><span class="sxs-lookup"><span data-stu-id="a9e07-132">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="a9e07-133">Il commit causerà servizi DevOps di Azure eseguire un processo di compilazione all'interno di un contenitore Docker e, al completamento del processo, eseguire il push un'immagine Docker nel Registro di sistema di Docker, come illustrato nella figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="a9e07-133">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![La prima parte del ciclo esterno prevede i passaggi da 1 a 3, dal codice, eseguire, eseguire il debug e convalida, quindi il repository di codice fino al passaggio di integrazione continua di compilazione e test](./media/image2.png)

<span data-ttu-id="a9e07-135">**Figura 5-2**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-135">**Figure 5-2**.</span></span> <span data-ttu-id="a9e07-136">I passaggi relativi all'integrazione continua</span><span class="sxs-lookup"><span data-stu-id="a9e07-136">The steps involved in CI</span></span>

<span data-ttu-id="a9e07-137">Ecco i passaggi di base degli elementi di configurazione del flusso di lavoro con Docker e servizi di Azure DevOps:</span><span class="sxs-lookup"><span data-stu-id="a9e07-137">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="a9e07-138">Lo sviluppatore effettua il push di un commit a un repository di controllo del codice sorgente (Git/DevOps servizi di Azure, GitHub e così via).</span><span class="sxs-lookup"><span data-stu-id="a9e07-138">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="a9e07-139">Se si usa Azure DevOps Service o Git, integrazione continua è incorporato, il che significa che è sufficiente selezionare una casella di controllo in servizi di Azure DevOps.</span><span class="sxs-lookup"><span data-stu-id="a9e07-139">If you're using Azure DevOps Services or Git, CI is built in, which means that it is as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="a9e07-140">Se si usa un controllo del codice sorgente esterna (ad esempio, GitHub), un `webhook` verrà notificare all'utente di servizi di Azure DevOps dell'aggiornamento o eseguire il push Git e GitHub.</span><span class="sxs-lookup"><span data-stu-id="a9e07-140">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="a9e07-141">Servizi di Azure DevOps estrae il repository di controllo del codice sorgente, tra cui il documento Dockerfile che descrivono l'immagine, nonché il codice dell'applicazione e di test.</span><span class="sxs-lookup"><span data-stu-id="a9e07-141">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="a9e07-142">Servizi di Azure DevOps crea un'immagine Docker e l'etichetta con un numero di build.</span><span class="sxs-lookup"><span data-stu-id="a9e07-142">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="a9e07-143">Servizi di Azure DevOps crea un'istanza del contenitore Docker all'interno dell'Host Docker con provisioning e vengono eseguiti i test appropriati.</span><span class="sxs-lookup"><span data-stu-id="a9e07-143">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="a9e07-144">Se i test hanno esito positivo, l'immagine è rietichettato prima di tutto a un nome significativo, in modo da sapere è una compilazione"documento" (ad esempio "/ 1.0.0" o qualsiasi altra etichetta) e quindi eseguire il push nel Registro di Docker (Docker Hub, registro contenitori di Azure, DTR e così via)</span><span class="sxs-lookup"><span data-stu-id="a9e07-144">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="a9e07-145">Implementazione della pipeline di integrazione continua con servizi di Azure DevOps e l'estensione Docker per i servizi di Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="a9e07-145">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="a9e07-146">Visual Studio Azure DevOps Services contiene modelli di rilascio che è possibile usare nella tua pipeline di integrazione continua/recapito Continuo con cui è possibile compilare immagini Docker, eseguire il push delle immagini Docker in un registro Docker autenticato, eseguire le immagini Docker o eseguire altre operazioni offerte dal & di compilazione il CLI di Docker.</span><span class="sxs-lookup"><span data-stu-id="a9e07-146">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="a9e07-147">Aggiunge anche un'attività di Docker Compose che è possibile usare per compilare, eseguire il push ed eseguire applicazioni Docker multi-contenitore o eseguire altre operazioni offerte dal comando Docker Compose, come illustrato nella figura 5-3.</span><span class="sxs-lookup"><span data-stu-id="a9e07-147">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Visualizzazione browser della pipeline di integrazione continua di Docker in Azure DevOps](./media/image3.png)

<span data-ttu-id="a9e07-149">**Figura 5-3**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-149">**Figure 5-3**.</span></span> <span data-ttu-id="a9e07-150">La pipeline di integrazione continua di Docker in servizi di DevOps di Azure tra cui compilazione e i modelli di rilascio e attività associate.</span><span class="sxs-lookup"><span data-stu-id="a9e07-150">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="a9e07-151">È possibile usare questi modelli e le attività per costruire gli artefatti di integrazione continua/recapito Continuo per compilare / testa e Distribuisci in Azure Service Fabric, Azure Kubernetes Service e le offerte di simile.</span><span class="sxs-lookup"><span data-stu-id="a9e07-151">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="a9e07-152">Con queste attività di Visual Studio Team Services, una compilazione Host Docker Linux/macchine Virtuali sottoposte a provisioning in Azure e il registro Docker preferito (registro contenitori di Azure, Hub Docker, Docker privato DTR o qualsiasi altro registro Docker) è possibile assemblare la pipeline di integrazione continua di Docker in un molto coerente.</span><span class="sxs-lookup"><span data-stu-id="a9e07-152">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="a9e07-153">***Requisiti:***</span><span class="sxs-lookup"><span data-stu-id="a9e07-153">***Requirements:***</span></span>

- <span data-ttu-id="a9e07-154">Servizi di Azure DevOps o per le installazioni locali, Team Foundation Server 2015 Update 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="a9e07-154">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="a9e07-155">Un agente di servizi di Azure DevOps con i file binari Docker.</span><span class="sxs-lookup"><span data-stu-id="a9e07-155">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="a9e07-156">Un modo semplice per creare uno di questi agenti è usare Docker per eseguire un contenitore in base all'immagine Docker dell'agente di servizi di Azure DevOps.</span><span class="sxs-lookup"><span data-stu-id="a9e07-156">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [! INFORMAZIONI]<span data-ttu-id="a9e07-157"> per leggere ulteriori informazioni su un'integrazione continua Docker di Azure DevOps servizi di assemblaggio di pipeline e visualizzare le procedure dettagliate, visitare i siti seguenti:</span><span class="sxs-lookup"><span data-stu-id="a9e07-157"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="a9e07-158">Esecuzione di un agente di Visual Studio Team Services (ora servizi di DevOps di Azure) come contenitore Docker: \\</span><span class="sxs-lookup"><span data-stu-id="a9e07-158">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: \\</span></span>
>   [*https://hub.docker.com/r/microsoft/vsts-agent/*](https://hub.docker.com/r/microsoft/vsts-agent/)
>
> - <span data-ttu-id="a9e07-159">Creazione di immagini Linux Docker per .NET Core con i servizi di Azure DevOps: \\</span><span class="sxs-lookup"><span data-stu-id="a9e07-159">Building .NET Core Linux Docker images with Azure DevOps Services: \\</span></span>
>   [*https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/*](https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/)
>
> - <span data-ttu-id="a9e07-160">Creazione di un basato su Linux con Visual Studio Team Service consentono di creare macchina con supporto Docker: \\</span><span class="sxs-lookup"><span data-stu-id="a9e07-160">Building a Linux-based Visual Studio Team Service build machine with Docker support: \\</span></span>
>   [*http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support*](http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support)

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="a9e07-161">Integrare, testare e convalidare le applicazioni Docker multi-contenitore</span><span class="sxs-lookup"><span data-stu-id="a9e07-161">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="a9e07-162">In genere, la maggior parte delle applicazioni Docker sono composti da più contenitori anziché un singolo contenitore.</span><span class="sxs-lookup"><span data-stu-id="a9e07-162">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="a9e07-163">Un buon esempio è un'applicazione orientata ai microservizi per i quali sarebbe necessario un contenitore per ogni microservizio.</span><span class="sxs-lookup"><span data-stu-id="a9e07-163">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="a9e07-164">Ma, anche senza seguire strettamente i modelli di approccio di microservizi, è probabile che l'applicazione Docker potrebbe essere composte da più contenitori o servizi.</span><span class="sxs-lookup"><span data-stu-id="a9e07-164">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="a9e07-165">Di conseguenza, dopo aver compilato i contenitori di applicazioni nella pipeline di integrazione continua, è anche necessario distribuire, integrare e testare l'applicazione nel suo complesso con tutti i contenitori all'interno di un host Docker integration o persino in un cluster di test al quale sono i contenitori distribuito.</span><span class="sxs-lookup"><span data-stu-id="a9e07-165">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="a9e07-166">Se si usa un singolo host, è possibile usare i comandi di Docker, ad esempio docker-compose per compilare e distribuire i contenitori correlati per testare e convalidare l'ambiente Docker in una singola macchina virtuale.</span><span class="sxs-lookup"><span data-stu-id="a9e07-166">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="a9e07-167">Tuttavia, se si lavora con un cluster dell'agente di orchestrazione DC/OS, Kubernetes o Docker Swarm, è necessario distribuire i contenitori tramite un meccanismo diverso o un agente di orchestrazione, a seconda di selezionato cluster o utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-167">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="a9e07-168">Di seguito sono tipi diversi di test che è possibile eseguire con i contenitori Docker:</span><span class="sxs-lookup"><span data-stu-id="a9e07-168">Following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="a9e07-169">Gli unit test per i contenitori Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-169">Unit tests for Docker containers</span></span>

- <span data-ttu-id="a9e07-170">Test dei gruppi di applicazioni correlate o microservizi</span><span class="sxs-lookup"><span data-stu-id="a9e07-170">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="a9e07-171">Testare in produzione e "canary" nelle versioni</span><span class="sxs-lookup"><span data-stu-id="a9e07-171">Test in production and "canary" releases</span></span>

<span data-ttu-id="a9e07-172">Il punto importante è che quando si esegue l'integrazione e test funzionali, è necessario eseguire questi test da fuori dai contenitori.</span><span class="sxs-lookup"><span data-stu-id="a9e07-172">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="a9e07-173">Test non sono contenuti o eseguiti nei contenitori che si sta distribuendo, poiché i contenitori sono basati su immagini statiche che devono essere esattamente come quelle cui dovrà essere distribuito nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-173">Tests are not contained or run in the containers you are deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="a9e07-174">Un'opzione possibile quando i test più scenari avanzati, ad esempio tra diversi cluster (test cluster, cluster di gestione temporanea e cluster di produzione) consiste nel pubblicare le immagini in un registro, in modo che possono essere testata in cluster diversi.</span><span class="sxs-lookup"><span data-stu-id="a9e07-174">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="a9e07-175">Eseguire il push dell'immagine Docker personalizzata dell'applicazione in globale registro Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-175">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="a9e07-176">Dopo che le immagini Docker sono state testate e convalidate, è opportuno assegnare contrassegni e pubblicarli nel registro Docker.</span><span class="sxs-lookup"><span data-stu-id="a9e07-176">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="a9e07-177">Il Registro di Docker è un'informazione fondamentale nel ciclo di vita dell'applicazione Docker perché è la posizione centrale in cui vengono archiviati i test personalizzati (noto anche come "immagini documento") per la distribuzione in ambienti di controllo di qualità e produzione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-177">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="a9e07-178">Analogamente al modo in cui il codice dell'applicazione archiviato nel repository di controllo del codice sorgente (Git, e così via) è il "source of truth", il Registro di Docker è la "fonte di veridicità" per applicazione binario o bit per la distribuzione in ambienti di produzione o di controllo di qualità.</span><span class="sxs-lookup"><span data-stu-id="a9e07-178">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="a9e07-179">In genere, si potrebbe voler avere repository privato per le immagini personalizzate in un repository privato in Registro contenitori di Azure in un'istanza di registro in locale, ad esempio registro attendibile Docker o in un registro di sistema di cloud pubblico con accesso limitato (ad esempio Hub docker), anche se in quest'ultimo caso, se il codice non è open source e deve considerare attendibile la sicurezza del fornitore.</span><span class="sxs-lookup"><span data-stu-id="a9e07-179">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="a9e07-180">In entrambi i casi, il metodo da utilizzare è simile e si basa sul `docker push` comando, come illustrato nella figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="a9e07-180">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Nel passaggio 3, per la compilazione di integrazione e test (CI) è possibile pubblicare le immagini docker risultanti in un registro privato o pubblico.](./media/image4.png)

<span data-ttu-id="a9e07-182">**Figura 5-4**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-182">**Figure 5-4**.</span></span> <span data-ttu-id="a9e07-183">Pubblicazione di immagini personalizzate al registro Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-183">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="a9e07-184">Sono disponibili più offerte di registri Docker da fornitori cloud, ad esempio registro contenitori di Azure, registro contenitori di servizi Web Amazon, registro contenitori di Google, Quay del Registro di sistema e così via.</span><span class="sxs-lookup"><span data-stu-id="a9e07-184">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="a9e07-185">Usa le attività di Docker, eseguire il push di un set di immagini di servizio definiti da un `docker-compose.yml` file, con più tag, in un registro Docker autenticato (ad esempio, registro contenitori di Azure), come illustrato nella figura 5-5.</span><span class="sxs-lookup"><span data-stu-id="a9e07-185">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Visualizzazione di esplorazione del passaggio per la pubblicazione di immagini in un registro di sistema dalla metodologia DevOps di Azure.](./media/image5.png)

<span data-ttu-id="a9e07-187">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-187">**Figure 5-5**.</span></span> <span data-ttu-id="a9e07-188">Con servizi di Azure DevOps per le immagini personalizzate di pubblicazione in un registro Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-188">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [! INFORMAZIONI]<span data-ttu-id="a9e07-189"> per altre informazioni su registro contenitori di Azure, vedere <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="a9e07-189"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="a9e07-190">Passaggio 4: Recapito Continuo, distribuzione</span><span class="sxs-lookup"><span data-stu-id="a9e07-190">Step 4: CD, Deploy</span></span>

<span data-ttu-id="a9e07-191">Immutabilità delle immagini Docker assicura una distribuzione ripetibile con ciò che ha sviluppato, testato con integrazione continua ed eseguire nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-191">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="a9e07-192">Dopo aver creato le immagini Docker applicazione pubblicate nel registro Docker (privato o pubblico), è possibile distribuirle agli ambienti diversi che potrebbe essere (ambiente di produzione, controllo qualità, staging, e così via) dalla pipeline di recapito Continuo tramite servizi di Azure DevOps le attività della pipeline o servizi di Release Management per Azure DevOps.</span><span class="sxs-lookup"><span data-stu-id="a9e07-192">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="a9e07-193">Tuttavia, a questo punto dipende il tipo di applicazione Docker si distribuiscono.</span><span class="sxs-lookup"><span data-stu-id="a9e07-193">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="a9e07-194">Distribuire una semplice applicazione (da una composizione e la distribuzione punto di vista), ad esempio un monolitica dell'applicazione che comprende alcuni contenitori o servizi e distribuita da alcuni server o macchine virtuali è diversa dalla distribuzione di un'applicazione più complessa, ad esempio un applicazione orientata ai microservizi con capacità su scala molto vasta.</span><span class="sxs-lookup"><span data-stu-id="a9e07-194">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="a9e07-195">Questi due scenari sono illustrati nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="a9e07-195">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="a9e07-196">Distribuzione composto da applicazioni Docker in più ambienti Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-196">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="a9e07-197">Verrà ora illustrato lo scenario meno complesso: distribuzione semplice host Docker (macchine virtuali o server) in un singolo ambiente o a più ambienti (controllo di qualità, staging e produzione).</span><span class="sxs-lookup"><span data-stu-id="a9e07-197">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="a9e07-198">In questo scenario, la pipeline di distribuzione può essere utilizzata internamente docker-compose (delle attività di distribuzione di servizi di Azure DevOps) per distribuire le applicazioni Docker con il relativo set correlati di contenitori o servizi, come illustrato nella figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="a9e07-198">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Distribuire il CD di passaggio (4) è possibile pubblicare in ambienti diversi, ad esempio q & a, gestione temporanea e produzione.](./media/image6.png)

<span data-ttu-id="a9e07-200">**Figura 5-6**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-200">**Figure 5-6**.</span></span> <span data-ttu-id="a9e07-201">Distribuzione di contenitori di applicazioni semplici registro ambienti host di Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-201">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="a9e07-202">Figura 5-7 evidenzia come è possibile connettersi l'elemento di configurazione di compilazione per gli ambienti di test/controllo qualità tramite servizi di Azure DevOps facendo clic su Docker Compose nella finestra di dialogo Aggiungi attività.</span><span class="sxs-lookup"><span data-stu-id="a9e07-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="a9e07-203">Tuttavia, durante la distribuzione in ambienti di gestione temporanea o produzione, in genere utilizzare funzionalità di Release Management, gestione di più ambienti (ad esempio di controllo di qualità, staging e produzione).</span><span class="sxs-lookup"><span data-stu-id="a9e07-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="a9e07-204">Se si esegue la distribuzione host Docker singoli, Usa i servizi di Azure DevOps "Docker Compose" task (che sta richiamando il `docker-compose up` comando dietro le quinte).</span><span class="sxs-lookup"><span data-stu-id="a9e07-204">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="a9e07-205">Se si esegue la distribuzione del servizio contenitore di Azure, Usa l'attività di distribuzione di Docker, come illustrato nella sezione che segue.</span><span class="sxs-lookup"><span data-stu-id="a9e07-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Visualizzazione nel browser dell'aggiunta di un'attività di Docker Compose.](./media/image7.png)

<span data-ttu-id="a9e07-207">**Figura 5-7**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-207">**Figure 5-7**.</span></span> <span data-ttu-id="a9e07-208">Aggiunta di un'attività di Docker Compose in una pipeline di servizi di Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="a9e07-208">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="a9e07-209">Quando si crea una versione in servizi di Azure DevOps, richiede un set di elementi di input.</span><span class="sxs-lookup"><span data-stu-id="a9e07-209">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="a9e07-210">Questi elementi devono essere non modificabile per la durata della versione, per tutti gli ambienti.</span><span class="sxs-lookup"><span data-stu-id="a9e07-210">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="a9e07-211">Quando si introducono i contenitori, gli elementi di input identificano immagini in un registro per la distribuzione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-211">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="a9e07-212">A seconda del modo in cui vengono identificate queste immagini, non è garantito che rimangono invariati per tutta la durata della versione, il più ovvio case in corso quando si fa riferimento `myimage:latest` da un `docker-compose` file.</span><span class="sxs-lookup"><span data-stu-id="a9e07-212">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="a9e07-213">I modelli di servizi di Azure DevOps offrono la possibilità di generare gli artefatti di compilazione che contengono immagini specifiche del Registro di sistema esegue il digest garantite identificare in modo univoco la stessa immagine binaria.</span><span class="sxs-lookup"><span data-stu-id="a9e07-213">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="a9e07-214">Si tratta di ciò che si vuole usare come input per una versione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-214">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="a9e07-215">La gestione delle versioni per gli ambienti Docker usando Azure DevOps Services Release Management</span><span class="sxs-lookup"><span data-stu-id="a9e07-215">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="a9e07-216">Tramite i modelli di servizi di Azure DevOps, è possibile creare una nuova immagine, pubblicarlo in un registro Docker, eseguirlo in Linux o Windows host e usare i comandi, ad esempio `docker-compose` distribuire più contenitori come un'intera applicazione, tutto grazie a DevOps di Azure Servizi destinate per più ambienti, le funzionalità di Release Management come illustrato nella figura 5-8.</span><span class="sxs-lookup"><span data-stu-id="a9e07-216">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Visualizzazione di esplorazione di DevOps di Azure, configurazione di Docker compose versioni.](./media/image8.png)

<span data-ttu-id="a9e07-218">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-218">**Figure 5-8**.</span></span> <span data-ttu-id="a9e07-219">Configurazione delle attività di Azure DevOps servizi Docker Compose da servizi di Release Management per Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="a9e07-219">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="a9e07-220">Tuttavia, tenere presente che lo scenario illustrato nella figura 5-6 e implementato nella figura 5-8 è semplice (distribuzione di macchine virtuali e host Docker singoli e vi sarà un singolo contenitore o un'istanza per ogni immagine) e probabilmente deve essere usato solo per lo sviluppo o test sce narios.</span><span class="sxs-lookup"><span data-stu-id="a9e07-220">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="a9e07-221">Nella maggior parte degli scenari di produzione dell'organizzazione, si potrebbe voler disponibile la disponibilità elevata, facile da gestire la scalabilità, bilanciamento del carico tra più nodi, i server e le macchine virtuali, oltre a "failover intelligente", quindi se un server o un nodo ha esito negativo, i servizi e contenitori verranno spostati a un altro server host o macchina virtuale.</span><span class="sxs-lookup"><span data-stu-id="a9e07-221">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="a9e07-222">In tal caso, è necessario tecnologie più avanzate, ad esempio i cluster del contenitore, gli agenti di orchestrazione e le utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-222">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="a9e07-223">Di conseguenza, il modo per distribuire a tali cluster è tramite la gestione di scenari avanzati illustrato nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="a9e07-223">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="a9e07-224">Distribuzione di applicazioni di Docker per i cluster di Docker</span><span class="sxs-lookup"><span data-stu-id="a9e07-224">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="a9e07-225">La natura delle applicazioni distribuite richiede risorse di calcolo che vengono distribuite anche.</span><span class="sxs-lookup"><span data-stu-id="a9e07-225">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="a9e07-226">Per le funzionalità a livello di produzione, è necessario disporre di funzionalità che forniscono una scalabilità elevata e disponibilità elevata basata sulle risorse in pool di clustering.</span><span class="sxs-lookup"><span data-stu-id="a9e07-226">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="a9e07-227">È possibile distribuire manualmente i contenitori a tali cluster da uno strumento della riga di comando o un'interfaccia utente, web, ma è necessario riservare questo tipo di attività manuale di test di distribuzione spot o scopi di gestione come la scalabilità orizzontale o di monitoraggio.</span><span class="sxs-lookup"><span data-stu-id="a9e07-227">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="a9e07-228">Dal punto di vista di CD e i servizi di Azure DevOps in particolare, è possibile eseguire le attività di distribuzione effettuata in modo speciale dagli ambienti di gestione del rilascio di servizi di Azure DevOps che consentirà di distribuire le applicazioni in contenitori per i cluster distribuiti nel contenitore Servizio, come illustrato nella figura 5-9.</span><span class="sxs-lookup"><span data-stu-id="a9e07-228">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Distribuire il CD di passaggio (4) è possibile pubblicare anche ai cluster tramite gli agenti di orchestrazione.](./media/image9.png)

<span data-ttu-id="a9e07-230">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-230">**Figure 5-9**.</span></span> <span data-ttu-id="a9e07-231">Distribuzione di applicazioni distribuite nel servizio contenitore di</span><span class="sxs-lookup"><span data-stu-id="a9e07-231">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="a9e07-232">Inizialmente, durante la distribuzione di determinati i cluster o gli agenti di orchestrazione, in genere utilizzare meccanismi per ogni agente di orchestrazione (vale a dire, Kubernetes e Service Fabric dispone di meccanismi di distribuzione diverso) e gli script di distribuzione specifici anziché il più semplice e facile da usare `docker-compose` dello strumento base il `docker-compose.yml` file di definizione.</span><span class="sxs-lookup"><span data-stu-id="a9e07-232">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="a9e07-233">Tuttavia, grazie all'attività distribuzione Docker di servizi di Azure DevOps, illustrato nella figura 5-10, è ora anche possibile distribuire per l'agente di orchestrazione supportati solo con cui si ha familiarità `docker-compose.yml` file perché lo strumento esegue tale "conversione" per l'utente (dalle `docker-compose.yml`file di formato necessari per l'agente di orchestrazione).</span><span class="sxs-lookup"><span data-stu-id="a9e07-233">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Visualizzazione di esplorazione del catalogo delle attività in DevOps di Azure, che mostra il Docker di attività di distribuzione.](./media/image10.png)

<span data-ttu-id="a9e07-235">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-235">**Figure 5-10**.</span></span> <span data-ttu-id="a9e07-236">Aggiunta dell'attività di distribuzione Docker per Gestione risorse di ambiente</span><span class="sxs-lookup"><span data-stu-id="a9e07-236">Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="a9e07-237">Figura 5-11 viene illustrato come è possibile modificare l'attività di distribuzione Docker e specificare il tipo di destinazione (Azure DC/OS del servizio contenitore, in questo caso), il File Docker Compose e la connessione al registro Docker (ad esempio registro contenitori di Azure o Hub Docker).</span><span class="sxs-lookup"><span data-stu-id="a9e07-237">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="a9e07-238">Si tratta di attività che recupererà le immagini Docker personalizzate pronti da usare per la distribuzione come i contenitori nel cluster.</span><span class="sxs-lookup"><span data-stu-id="a9e07-238">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Visualizzazione di esplorazione di DevOps di Azure, distribuire la definizione di attività dell'agente di orchestrazione.](./media/image11.png)

<span data-ttu-id="a9e07-240">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="a9e07-240">**Figure 5-11**.</span></span> <span data-ttu-id="a9e07-241">Docker Deploy attività definizione distribuzione a Azure DC/OS del servizio contenitore</span><span class="sxs-lookup"><span data-stu-id="a9e07-241">Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

> [! INFORMAZIONI]<span data-ttu-id="a9e07-242"> per altre informazioni sulla pipeline di recapito Continuo con servizi di Azure DevOps e Docker, visitare <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="a9e07-242"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="a9e07-243">Passaggio 5: Eseguire e gestire</span><span class="sxs-lookup"><span data-stu-id="a9e07-243">Step 5: Run and manage</span></span>

<span data-ttu-id="a9e07-244">Perché è in esecuzione e la gestione delle applicazioni in produzione dell'organizzazione a livello di è un argomento principale in e di se stesso e a causa di un tipo di operazioni e persone che lavorano a tale livello (operazioni IT), nonché l'ambito di grandi dimensioni di quest'area, è stata dedicata l'intero successivamente capitolo per spiegarlo.</span><span class="sxs-lookup"><span data-stu-id="a9e07-244">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="a9e07-245">Passaggio 6: Monitorare e diagnosticare</span><span class="sxs-lookup"><span data-stu-id="a9e07-245">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="a9e07-246">Questo argomento viene descritto anche entro i prossimi capitolo come parte delle attività che esegue in sistemi di produzione. Tuttavia, è importante evidenziare che di informazioni approfondite ottenute in questo passaggio è necessario inserire nuovamente al team di sviluppo in modo che l'applicazione viene continuamente migliorata.</span><span class="sxs-lookup"><span data-stu-id="a9e07-246">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="a9e07-247">Da tale punto di vista, è anche parte della metodologia DevOps, anche se l'attività e le operazioni comunemente eseguite dall'IT.</span><span class="sxs-lookup"><span data-stu-id="a9e07-247">From that point of view, it is also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="a9e07-248">Solo quando il monitoraggio e diagnostica è 100% entro l'area di autenticazione della metodologia DevOps sono i processi di monitoraggio e analitica eseguita dal team di sviluppo in ambienti di test o beta.</span><span class="sxs-lookup"><span data-stu-id="a9e07-248">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="a9e07-249">Questa operazione viene eseguita mediante l'esecuzione di test di carico o dal monitoraggio beta o ambienti di controllo di qualità, in cui permettere a beta tester sta provando le nuove versioni.</span><span class="sxs-lookup"><span data-stu-id="a9e07-249">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a9e07-250">[Precedente](index.md)
>[Successivo](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="a9e07-250">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
