---
title: Scelta tra classi e struct
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: KrzysztofCwalina
ms.openlocfilehash: 5041368ca1a440698c399c935ac72aba2002c3ba
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/28/2019
ms.locfileid: "64615271"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="a360b-102">Scelta tra classi e struct</span><span class="sxs-lookup"><span data-stu-id="a360b-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="a360b-103">Una delle decisioni di progettazione di base che deve affrontare ogni finestra di progettazione di framework è se un tipo di progettazione come una classe (un tipo riferimento) o uno struct (tipo di valore).</span><span class="sxs-lookup"><span data-stu-id="a360b-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="a360b-104">Buona conoscenza delle differenze nel comportamento dei tipi di riferimento e tipi di valore è essenziale per effettuare questa scelta.</span><span class="sxs-lookup"><span data-stu-id="a360b-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="a360b-105">La prima delle differenze tra i tipi di riferimento e tipi di valore verranno presi in considerazione è che i tipi di riferimento vengono allocati nell'heap e sottoposto a garbage collection, mentre i tipi di valore vengono allocati nello stack o inline nel che contiene i tipi e deallocato quando lo stack viene rimosso o quando deallocata relativo tipo contenitore.</span><span class="sxs-lookup"><span data-stu-id="a360b-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="a360b-106">Pertanto, le allocazioni e deallocazioni di tipi di valore sono in genere più economica rispetto alle allocazioni e deallocazioni dei tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="a360b-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="a360b-107">Successivamente, le matrici di riferimento sono tipi allocati out-of-line, vale a dire la matrice di elementi sono semplicemente i riferimenti alle istanze del tipo di riferimento che risiedono nell'heap.</span><span class="sxs-lookup"><span data-stu-id="a360b-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="a360b-108">Matrici di tipi valore vengono allocate inline, vale a dire che gli elementi della matrice sono le istanze effettive del tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="a360b-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="a360b-109">Pertanto, le allocazioni e deallocazioni di matrici di tipi valore sono molto più economiche rispetto alle allocazioni e deallocazioni delle matrici di tipo riferimento.</span><span class="sxs-lookup"><span data-stu-id="a360b-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="a360b-110">Inoltre, nella maggior parte dei casi le matrici di tipo valore presentano molto posizionamento ottimale dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="a360b-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="a360b-111">Differenza successiva è correlata all'utilizzo della memoria.</span><span class="sxs-lookup"><span data-stu-id="a360b-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="a360b-112">I tipi di valore compattati quando esegue il cast a un tipo riferimento o una delle interfacce implementate.</span><span class="sxs-lookup"><span data-stu-id="a360b-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="a360b-113">Ricevono unboxed quando esegue il cast nel tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="a360b-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="a360b-114">Poiché le finestre sono oggetti vengono allocati nell'heap e sottoposto a garbage collection, troppe operazioni conversione boxing e unboxing può avere un impatto negativo su heap, il garbage collector e infine le prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a360b-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="a360b-115">Al contrario, si verifica alcun tali boxing quando vengono eseguito il cast di tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="a360b-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="a360b-116">(Per altre informazioni, vedere [conversioni Boxing e Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="a360b-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="a360b-117">Le assegnazioni dei tipi riferimento successivamente, copiare il riferimento, mentre le assegnazioni dei tipi valore copiare l'intero valore.</span><span class="sxs-lookup"><span data-stu-id="a360b-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="a360b-118">Pertanto, le assegnazioni dei tipi di riferimento di grandi dimensioni sono più economiche rispetto all'assegnazione dei tipi di valori di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="a360b-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="a360b-119">Infine, i tipi di riferimento vengono passati per riferimento, mentre i tipi di valore vengono passati per valore.</span><span class="sxs-lookup"><span data-stu-id="a360b-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="a360b-120">Le modifiche a un'istanza di un tipo riferimento influiscono su tutti i riferimenti che puntano all'istanza.</span><span class="sxs-lookup"><span data-stu-id="a360b-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="a360b-121">Istanze del tipo di valore vengono copiate quando vengono passati per valore.</span><span class="sxs-lookup"><span data-stu-id="a360b-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="a360b-122">Quando viene modificata un'istanza di un tipo di valore, ovviamente non influirà proprie copie.</span><span class="sxs-lookup"><span data-stu-id="a360b-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="a360b-123">Poiché le copie non vengono create in modo esplicito dall'utente, ma vengono create in modo implicito quando gli argomenti vengono passati o i valori vengono restituiti, tipi di valore che possono essere modificati possono generare confusione a molti utenti.</span><span class="sxs-lookup"><span data-stu-id="a360b-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="a360b-124">Pertanto, i tipi di valore devono essere non modificabili.</span><span class="sxs-lookup"><span data-stu-id="a360b-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="a360b-125">Come regola generale, la maggior parte dei tipi in un framework deve essere classi.</span><span class="sxs-lookup"><span data-stu-id="a360b-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="a360b-126">Esistono tuttavia alcune situazioni in cui le caratteristiche di un tipo valore rendano più opportuno usare struct.</span><span class="sxs-lookup"><span data-stu-id="a360b-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="a360b-127">**✓ CONSIDER** definire una struttura invece di una classe, se le istanze del tipo sono ridotti e generalmente di breve durata o vengono comunemente incorporate in altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="a360b-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="a360b-128">**X AVOID** che definisce uno struct, a meno che il tipo dispone di tutte le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="a360b-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
- <span data-ttu-id="a360b-129">In modo logico rappresenta un singolo valore, simile ai tipi primitivi (`int`, `double`e così via.).</span><span class="sxs-lookup"><span data-stu-id="a360b-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
- <span data-ttu-id="a360b-130">Ha una dimensione di istanza inferiore a 16 byte.</span><span class="sxs-lookup"><span data-stu-id="a360b-130">It has an instance size under 16 bytes.</span></span>  
  
- <span data-ttu-id="a360b-131">Non è modificabile.</span><span class="sxs-lookup"><span data-stu-id="a360b-131">It is immutable.</span></span>  
  
- <span data-ttu-id="a360b-132">Non dovrà eseguire la conversione boxing di frequente.</span><span class="sxs-lookup"><span data-stu-id="a360b-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="a360b-133">In tutti gli altri casi, è necessario definire i tipi come classi.</span><span class="sxs-lookup"><span data-stu-id="a360b-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="a360b-134">*Parti protette da copyright © 2005, 2009 Microsoft Corporation. Tutti i diritti riservati.*</span><span class="sxs-lookup"><span data-stu-id="a360b-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="a360b-135">*Ristampato con l'autorizzazione di Pearson Education, Inc. dal [linee guida di progettazione di Framework: Convenzioni, linguaggi e modelli per le librerie .NET di riutilizzabile, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina e Brad Abrams, pubblicato il 22 ottobre 2008 da Addison-Wesley Professional come parte della serie di sviluppo di Microsoft Windows.*</span><span class="sxs-lookup"><span data-stu-id="a360b-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a360b-136">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="a360b-136">See also</span></span>

- [<span data-ttu-id="a360b-137">Linee guida per la progettazione di tipi</span><span class="sxs-lookup"><span data-stu-id="a360b-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)
- [<span data-ttu-id="a360b-138">Linee guida per la progettazione di Framework</span><span class="sxs-lookup"><span data-stu-id="a360b-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
