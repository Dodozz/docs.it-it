---
title: Raccolte thread-safe
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 7fad67c1a3c53cd83dec6bfa161333b5e20ab4c4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/23/2019
ms.locfileid: "61644711"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="33fbe-102">Raccolte thread-safe</span><span class="sxs-lookup"><span data-stu-id="33fbe-102">Thread-Safe Collections</span></span>
<span data-ttu-id="33fbe-103">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduce lo spazio dei nomi <xref:System.Collections.Concurrent?displayProperty=nameWithType>, che include diverse classi di raccolta sia thread-safe che scalabili.</span><span class="sxs-lookup"><span data-stu-id="33fbe-103">The [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="33fbe-104">Più thread possono aggiungere o rimuovere elementi da queste raccolte in modo sicuro ed efficiente, senza richiedere una sincronizzazione aggiuntiva nel codice utente.</span><span class="sxs-lookup"><span data-stu-id="33fbe-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="33fbe-105">Quando si scrive nuovo codice, usare le classi di raccolta simultanee ogni volta che più thread scriveranno nella raccolta contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="33fbe-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="33fbe-106">Se si prevede di leggere solo da una raccolta condivisa, è possibile usare le classi dello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="33fbe-107">È consigliabile evitare di usare le classi di raccolta 1.0 a meno che non sia necessario definire come destinazione il runtime di .NET Framework versione 1.1 o precedente.</span><span class="sxs-lookup"><span data-stu-id="33fbe-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="33fbe-108">Sincronizzazione dei thread nelle raccolte di .NET Framework 1.0 e 2.0</span><span class="sxs-lookup"><span data-stu-id="33fbe-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="33fbe-109">Le raccolte introdotte in .NET Framework 1.0 sono reperibili nello spazio dei nomi <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="33fbe-110">Queste raccolte, incluse le raccolte <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable> usate normalmente, supportano la thread safety con la proprietà `Synchronized`, che restituisce un wrapper thread-safe per la raccolta.</span><span class="sxs-lookup"><span data-stu-id="33fbe-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="33fbe-111">Il wrapper funziona bloccando l'intera raccolta in ogni operazione di aggiunta o rimozione.</span><span class="sxs-lookup"><span data-stu-id="33fbe-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="33fbe-112">Pertanto, ogni thread che tenta di accedere alla raccolta deve attendere il proprio turno per acquisire l'unico blocco.</span><span class="sxs-lookup"><span data-stu-id="33fbe-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="33fbe-113">Questa caratteristica non è scalabile e può causare un peggioramento delle prestazioni per le raccolte di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="33fbe-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="33fbe-114">Inoltre, la progettazione non è completamente protetta da race condition.</span><span class="sxs-lookup"><span data-stu-id="33fbe-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="33fbe-115">Per altre informazioni, vedere la pagina relativa alla [sincronizzazione nelle raccolte generiche](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/).</span><span class="sxs-lookup"><span data-stu-id="33fbe-115">For more information, see [Synchronization in Generic Collections](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/).</span></span>  
  
 <span data-ttu-id="33fbe-116">Le classi di raccolta introdotte in .NET Framework 2.0 sono reperibili nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="33fbe-117">Sono incluse <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> e così via.</span><span class="sxs-lookup"><span data-stu-id="33fbe-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="33fbe-118">che forniscono maggiore indipendenza dai tipi e migliori prestazioni rispetto alle classi di .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="33fbe-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="33fbe-119">Tuttavia, le classi di raccolta di .NET Framework 2.0 non forniscono la sincronizzazione dei thread. Quando gli elementi vengono aggiunti o rimossi contemporaneamente su più thread, la sincronizzazione deve essere gestita dal codice utente.</span><span class="sxs-lookup"><span data-stu-id="33fbe-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="33fbe-120">È quindi consigliabile usare le classi della raccolta simultanee in [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] perché forniscono non solo l'indipendenza dai tipi delle classi di raccolta di .NET Framework 2.0, ma anche una thread safety più efficiente e completa rispetto alle raccolte [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)].</span><span class="sxs-lookup"><span data-stu-id="33fbe-120">We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="33fbe-121">Blocco con granularità fine e meccanismi senza blocco</span><span class="sxs-lookup"><span data-stu-id="33fbe-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="33fbe-122">Alcuni tipi di raccolte simultanee usano meccanismi di sincronizzazione leggeri, ad esempio <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> e <xref:System.Threading.CountdownEvent>, che sono nuovi in [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span><span class="sxs-lookup"><span data-stu-id="33fbe-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span></span> <span data-ttu-id="33fbe-123">Questi tipi di sincronizzazione usano in genere la rotazione con *stato occupato* per breve periodi di tempo prima di impostare il thread in uno stato di attesa effettivo.</span><span class="sxs-lookup"><span data-stu-id="33fbe-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="33fbe-124">Quando si prevedono tempi di attesa molto brevi, la rotazione è molto meno dispendiosa a livello di elaborazione rispetto all'attesa, che implica una transizione del kernel complessa.</span><span class="sxs-lookup"><span data-stu-id="33fbe-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="33fbe-125">Per le classi di raccolta che usano la rotazione, questo livello di efficienza significa che più thread possono aggiungere e rimuovere elementi con una frequenza molto elevata.</span><span class="sxs-lookup"><span data-stu-id="33fbe-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="33fbe-126">Per altre informazioni sul confronto tra spin e blocco, vedere [SpinLock](../../../../docs/standard/threading/spinlock.md) e [SpinWait](../../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="33fbe-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="33fbe-127">Le classi <xref:System.Collections.Concurrent.ConcurrentQueue%601> e <xref:System.Collections.Concurrent.ConcurrentStack%601> non usano alcun blocco.</span><span class="sxs-lookup"><span data-stu-id="33fbe-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="33fbe-128">Al contrario, si basano sulle operazioni <xref:System.Threading.Interlocked> per ottenere la thread safety.</span><span class="sxs-lookup"><span data-stu-id="33fbe-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="33fbe-129">Poiché supportano <xref:System.Collections.ICollection>, le classi di raccolta simultanee offrono implementazioni per le proprietà <xref:System.Collections.ICollection.IsSynchronized%2A> e <xref:System.Collections.ICollection.SyncRoot%2A>, anche se queste sono irrilevanti.</span><span class="sxs-lookup"><span data-stu-id="33fbe-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="33fbe-130">`IsSynchronized` restituisce sempre `false` e `SyncRoot` è sempre `null` (`Nothing` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="33fbe-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="33fbe-131">Nella tabella seguente sono elencati i tipi di raccolta dello spazio dei nomi <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="33fbe-132">Tipo</span><span class="sxs-lookup"><span data-stu-id="33fbe-132">Type</span></span>|<span data-ttu-id="33fbe-133">Description</span><span class="sxs-lookup"><span data-stu-id="33fbe-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="33fbe-134">Offre la funzionalità di delimitazione e blocco per qualsiasi tipo che implementa <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="33fbe-135">Per altre informazioni, vedere [Panoramica di BlockingCollection](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="33fbe-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="33fbe-136">Implementazione thread-safe di un dizionario di coppie chiave-valore.</span><span class="sxs-lookup"><span data-stu-id="33fbe-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="33fbe-137">Implementazione thread-safe di una coda FIFO (First-In, First-Out).</span><span class="sxs-lookup"><span data-stu-id="33fbe-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="33fbe-138">Implementazione thread-safe di una coda LIFO (Last-In, First-Out).</span><span class="sxs-lookup"><span data-stu-id="33fbe-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="33fbe-139">Implementazione thread-safe di una raccolta non ordinata di elementi.</span><span class="sxs-lookup"><span data-stu-id="33fbe-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="33fbe-140">Interfaccia che un tipo deve implementare per essere usato in un oggetto `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="33fbe-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="33fbe-141">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="33fbe-141">Related Topics</span></span>  
  
|<span data-ttu-id="33fbe-142">Titolo</span><span class="sxs-lookup"><span data-stu-id="33fbe-142">Title</span></span>|<span data-ttu-id="33fbe-143">Description</span><span class="sxs-lookup"><span data-stu-id="33fbe-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="33fbe-144">Panoramica di BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="33fbe-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="33fbe-145">Descrive la funzionalità fornita dal tipo <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="33fbe-146">Procedura: Aggiungere e rimuovere elementi da un oggetto ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="33fbe-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="33fbe-147">Descrive come aggiungere e rimuovere elementi da un oggetto <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span><span class="sxs-lookup"><span data-stu-id="33fbe-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="33fbe-148">Procedura: Aggiungere e rimuovere singoli elementi di un oggetto BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="33fbe-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="33fbe-149">Descrive come aggiungere e recuperare elementi da una raccolta di blocco senza usare l'enumeratore di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="33fbe-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="33fbe-150">Procedura: Aggiungere funzionalità di delimitazione e blocco a una raccolta</span><span class="sxs-lookup"><span data-stu-id="33fbe-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="33fbe-151">Descrive come usare una classe di raccolta come meccanismo di archiviazione sottostante per una raccolta <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="33fbe-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="33fbe-152">Procedura: Usare ForEach per rimuovere elementi in un oggetto BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="33fbe-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="33fbe-153">Descrive come usare `foreach` (`For Each` in Visual Basic) per rimuovere tutti gli elementi in una raccolta di blocco.</span><span class="sxs-lookup"><span data-stu-id="33fbe-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="33fbe-154">Procedura: Usare matrici di raccolte di blocco in una pipeline</span><span class="sxs-lookup"><span data-stu-id="33fbe-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="33fbe-155">Descrive come usare più raccolte di blocco contemporaneamente per implementare una pipeline.</span><span class="sxs-lookup"><span data-stu-id="33fbe-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="33fbe-156">Procedura: Creare un pool di oggetti con un oggetto ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="33fbe-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="33fbe-157">Illustra come usare un contenitore simultaneo per migliorare le prestazioni negli scenari in cui è possibile riutilizzare gli oggetti anziché crearne continuamente di nuovi.</span><span class="sxs-lookup"><span data-stu-id="33fbe-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="33fbe-158">Riferimenti</span><span class="sxs-lookup"><span data-stu-id="33fbe-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
