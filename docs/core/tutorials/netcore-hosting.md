---
title: Scrivere un host di runtime di .NET Core personalizzato
description: Informazioni su come ospitare il runtime di .NET Core dal codice nativo per supportare scenari avanzati che richiedono il controllo del funzionamento del runtime di .NET Core.
author: mjrousos
ms.date: 12/21/2018
ms.custom: seodec18
ms.openlocfilehash: 27717cd68d2ef7c19289a9e06f99bb8767f2f582
ms.sourcegitcommit: 15ab532fd5e1f8073a4b678922d93b68b521bfa0
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 03/29/2019
ms.locfileid: "58654055"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="4d53d-103">Scrivere un host di .NET Core personalizzato per controllare il runtime di .NET dal codice nativo</span><span class="sxs-lookup"><span data-stu-id="4d53d-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="4d53d-104">Come tutto il codice gestito, le applicazioni .NET Core sono eseguite da un host.</span><span class="sxs-lookup"><span data-stu-id="4d53d-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="4d53d-105">L'host è responsabile dell'avvio del runtime, inclusi i componenti come JIT e Garbage Collector, nonché della chiamata dei punti di ingresso gestiti.</span><span class="sxs-lookup"><span data-stu-id="4d53d-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="4d53d-106">L'hosting del runtime di .NET Core rappresenta uno scenario avanzato e, nella maggior parte dei casi, gli sviluppatori .NET Core non devono occuparsi dell'hosting poiché i processi di compilazione di .NET Core includono un host predefinito per l'esecuzione delle applicazioni .NET Core.</span><span class="sxs-lookup"><span data-stu-id="4d53d-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="4d53d-107">Tuttavia, in alcune circostanze particolari può essere utile ospitare in modo esplicito il runtime di .NET Core per richiamare il codice gestito in un processo nativo o per avere maggior controllo sul funzionamento del runtime.</span><span class="sxs-lookup"><span data-stu-id="4d53d-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="4d53d-108">Questo articolo offre una panoramica dei passaggi necessari per avviare il runtime di .NET Core dal codice nativo ed eseguire al suo interno il codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="4d53d-109">Prerequisiti</span><span class="sxs-lookup"><span data-stu-id="4d53d-109">Prerequisites</span></span>

<span data-ttu-id="4d53d-110">Poiché gli host sono applicazioni native, in questa esercitazione verrà descritta la costruzione di un'applicazione C++ per l'hosting di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="4d53d-110">Because hosts are native applications, this tutorial will cover constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="4d53d-111">Sarà necessario un ambiente di sviluppo C++, come quello incluso in [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs).</span><span class="sxs-lookup"><span data-stu-id="4d53d-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="4d53d-112">Poiché sarà necessaria anche un'applicazione .NET Core semplice con cui testare l'host, installare [.NET Core SDK](https://www.microsoft.com/net/core) e [creare una piccola app di test .NET Core](../../core/tutorials/with-visual-studio.md), ad esempio un'app 'Hello World'.</span><span class="sxs-lookup"><span data-stu-id="4d53d-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://www.microsoft.com/net/core) and [build a small .NET Core test app](../../core/tutorials/with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="4d53d-113">L'app 'Hello World' creata dal nuovo modello di progetto della console di .NET Core è sufficiente.</span><span class="sxs-lookup"><span data-stu-id="4d53d-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="4d53d-114">API di hosting</span><span class="sxs-lookup"><span data-stu-id="4d53d-114">Hosting APIs</span></span>
<span data-ttu-id="4d53d-115">Per l'hosting di .NET Core è possibile usare due API diverse.</span><span class="sxs-lookup"><span data-stu-id="4d53d-115">There are two different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="4d53d-116">Questo documento e i relativi [esempi](https://github.com/dotnet/samples/tree/master/core/hosting) associati illustrano entrambe le opzioni.</span><span class="sxs-lookup"><span data-stu-id="4d53d-116">This document (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) cover both options.</span></span>

* <span data-ttu-id="4d53d-117">Il metodo preferito per l'hosting del runtime di .NET Core è costituito dall'API [CoreClrHost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h).</span><span class="sxs-lookup"><span data-stu-id="4d53d-117">The preferred method of hosting the .NET Core runtime is with the [CoreClrHost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="4d53d-118">Questa API espone le funzioni necessarie per avviare e arrestare facilmente il runtime e per richiamare il codice gestito tramite l'avvio di un file con estensione exe gestito o la chiamata di metodi gestiti statici.</span><span class="sxs-lookup"><span data-stu-id="4d53d-118">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>
* <span data-ttu-id="4d53d-119">È possibile ospitare .NET Core anche tramite l'interfaccia `ICLRRuntimeHost4` in [mscoree.h](https://github.com/dotnet/coreclr/blob/master/src/pal/prebuilt/inc/mscoree.h).</span><span class="sxs-lookup"><span data-stu-id="4d53d-119">.NET Core can also be hosted with the `ICLRRuntimeHost4` interface in [mscoree.h](https://github.com/dotnet/coreclr/blob/master/src/pal/prebuilt/inc/mscoree.h).</span></span> <span data-ttu-id="4d53d-120">Questa API è stata introdotta prima di CoreClrHost.h ed è quindi possibile che se ne sia già osservato l'uso in host precedenti.</span><span class="sxs-lookup"><span data-stu-id="4d53d-120">This API has been around longer than CoreClrHost.h, so you may have seen older hosts using it.</span></span> <span data-ttu-id="4d53d-121">L'API funziona ancora e consente un livello di controllo leggermente superiore sul processo di hosting rispetto a CoreClrHost.</span><span class="sxs-lookup"><span data-stu-id="4d53d-121">It still works and allows a bit more control over the hosting process than CoreClrHost.</span></span> <span data-ttu-id="4d53d-122">Per la maggior parte degli scenari, CoreClrHost.h è tuttavia il metodo attualmente preferito grazie alla maggiore semplicità delle relative API.</span><span class="sxs-lookup"><span data-stu-id="4d53d-122">For most scenarios, though, CoreClrHost.h is preferred now because of its simpler APIs.</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="4d53d-123">Host di esempio</span><span class="sxs-lookup"><span data-stu-id="4d53d-123">Sample Hosts</span></span>
<span data-ttu-id="4d53d-124">Nel repository GitHub dotnet/samples sono disponibili [host di esempio](https://github.com/dotnet/samples/tree/master/core/hosting) che illustrano i passaggi descritti nelle esercitazioni riportate di seguito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-124">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="4d53d-125">I commenti presenti negli esempi associano chiaramente i passaggi numerati di queste esercitazioni al punto in cui vengono eseguiti nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="4d53d-125">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="4d53d-126">Per istruzioni sul download, vedere [Esempi ed esercitazioni](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span><span class="sxs-lookup"><span data-stu-id="4d53d-126">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span></span>

<span data-ttu-id="4d53d-127">Tenere presente che gli host di esempio sono destinati all'uso ai fini dell'apprendimento. In questi host, progettati per enfatizzare la leggibilità più che l'efficienza, il controllo degli errori non è prioritario.</span><span class="sxs-lookup"><span data-stu-id="4d53d-127">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span> <span data-ttu-id="4d53d-128">Nel repository [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) sono disponibili esempi di host più reali.</span><span class="sxs-lookup"><span data-stu-id="4d53d-128">More real-world host samples are available in the [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) repository.</span></span> <span data-ttu-id="4d53d-129">In particolare, l'[host CoreRun](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun) e l'[host CoreRun Unix](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/unixcorerun) sono ottimi host di uso generale da studiare dopo aver esaminato questi esempi più semplici.</span><span class="sxs-lookup"><span data-stu-id="4d53d-129">The [CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun) and [Unix CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/unixcorerun), in particular, are good general-purpose hosts to study after reading through these simpler samples.</span></span>

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="4d53d-130">Creare un host tramite CoreClrHost.h</span><span class="sxs-lookup"><span data-stu-id="4d53d-130">Create a host using CoreClrHost.h</span></span>

<span data-ttu-id="4d53d-131">La procedura seguente illustra come usare l'API CoreClrHost.h per avviare il runtime di .NET Core in un'applicazione nativa e chiamare un metodo statico gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-131">The following steps detail how to use the CoreClrHost.h API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="4d53d-132">I frammenti di codice disponibili in questo documento usano alcune API specifiche di Windows, ma l'[host di esempio completo](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) include percorsi di codice Windows e Linux.</span><span class="sxs-lookup"><span data-stu-id="4d53d-132">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="4d53d-133">Passaggio 1: Trovare e caricare CoreCLR</span><span class="sxs-lookup"><span data-stu-id="4d53d-133">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="4d53d-134">Le API del runtime di .NET Core si trovano in *coreclr.dll* (in Windows), in *libcoreclr.so* (in Linux) o in *libcoreclr.dylib* (in macOS).</span><span class="sxs-lookup"><span data-stu-id="4d53d-134">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="4d53d-135">Il primo passaggio per l'hosting di .NET Core consiste nel caricare la libreria CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="4d53d-135">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="4d53d-136">Alcuni host eseguono il probe in diversi percorsi o usano parametri di input per trovare la libreria mentre altri la caricano da un determinato percorso, ad esempio una posizione accanto all'host o il percorso di un computer.</span><span class="sxs-lookup"><span data-stu-id="4d53d-136">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="4d53d-137">Dopo che è stata trovata, la libreria viene caricata con `LoadLibraryEx` (in Windows) o `dlopen` (in Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="4d53d-137">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/Mac).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="4d53d-138">Passaggio 2: Ottenere le funzioni di hosting di .NET Core</span><span class="sxs-lookup"><span data-stu-id="4d53d-138">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="4d53d-139">CoreClrHost include diversi metodi importanti utili per l'hosting di .NET Core:</span><span class="sxs-lookup"><span data-stu-id="4d53d-139">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="4d53d-140">`coreclr_initialize`: avvia il runtime di .NET Core e configura l'AppDomain predefinito (e unico dominio dell'applicazione).</span><span class="sxs-lookup"><span data-stu-id="4d53d-140">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="4d53d-141">`coreclr_execute_assembly`: esegue un assembly gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-141">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="4d53d-142">`coreclr_create_delegate`: crea un puntatore di funzione a un metodo gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-142">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="4d53d-143">`coreclr_shutdown`: arresta il runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="4d53d-143">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="4d53d-144">`coreclr_shutdown_2`: come `coreclr_shutdown`, ma recupera anche il codice di uscita del codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-144">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="4d53d-145">Dopo aver caricato la libreria CoreCLR, il passaggio successivo consiste nell'ottenere i riferimenti a queste funzioni tramite `GetProcAddress` (in Windows) o `dlsym` (in Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="4d53d-145">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/Mac).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="4d53d-146">Passaggio 3: Preparare le proprietà di runtime</span><span class="sxs-lookup"><span data-stu-id="4d53d-146">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="4d53d-147">Prima di avviare il runtime è necessario preparare alcune proprietà per specificare il comportamento, in particolare del caricatore di assembly.</span><span class="sxs-lookup"><span data-stu-id="4d53d-147">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="4d53d-148">Le proprietà comuni includono:</span><span class="sxs-lookup"><span data-stu-id="4d53d-148">Common properties include:</span></span>

* <span data-ttu-id="4d53d-149">`TRUSTED_PLATFORM_ASSEMBLIES` Elenco di percorsi di assembly, delimitato da ";" in Windows e da ":" in Linux, che il runtime riuscirà a risolvere per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="4d53d-149">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="4d53d-150">Alcuni host includono manifesti hardcoded con l'elenco degli assembly che possono caricare.</span><span class="sxs-lookup"><span data-stu-id="4d53d-150">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="4d53d-151">Altri inseriranno una libreria in determinate posizioni, ad esempio accanto a *coreclr.dll*, in questo elenco.</span><span class="sxs-lookup"><span data-stu-id="4d53d-151">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="4d53d-152">`APP_PATHS` Elenco di percorsi in cui eseguire il probe se un assembly non viene trovato nell'elenco degli assembly di piattaforma attendibili (TPA).</span><span class="sxs-lookup"><span data-stu-id="4d53d-152">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="4d53d-153">Poiché l'host ha un maggiore controllo su quali assembly vengono caricati tramite l'elenco TPA, è consigliabile che gli host determinino gli assembly che prevedono di caricare e li elenchino in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-153">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="4d53d-154">Se è necessaria l'esecuzione del probe al runtime, tuttavia, questa proprietà può abilitare tale scenario.</span><span class="sxs-lookup"><span data-stu-id="4d53d-154">If probing at runtime is needed, however, this property can enable that scenario.</span></span>
*  <span data-ttu-id="4d53d-155">`APP_NI_PATHS` Elenco simile ad APP_PATHS ma che deve includere i percorsi in cui verrà eseguito il probe di immagini native.</span><span class="sxs-lookup"><span data-stu-id="4d53d-155">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
*  <span data-ttu-id="4d53d-156">`NATIVE_DLL_SEARCH_DIRECTORIES` Questa proprietà è un elenco di percorsi in cui il caricatore esegue il probe quando cerca librerie native chiamate tramite p/invoke.</span><span class="sxs-lookup"><span data-stu-id="4d53d-156">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
*  <span data-ttu-id="4d53d-157">`PLATFORM_RESOURCE_ROOTS` Questo elenco include i percorsi in cui eseguire il probe di assembly satelliti di risorse in sottodirectory specifiche delle impostazioni cultura.</span><span class="sxs-lookup"><span data-stu-id="4d53d-157">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>

<span data-ttu-id="4d53d-158">In questo host di esempio l'elenco TPA viene creato includendo semplicemente tutte le librerie presenti nella directory corrente:</span><span class="sxs-lookup"><span data-stu-id="4d53d-158">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="4d53d-159">Poiché l'esempio è semplice, è necessaria solo la proprietà `TRUSTED_PLATFORM_ASSEMBLIES`:</span><span class="sxs-lookup"><span data-stu-id="4d53d-159">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="4d53d-160">Passaggio 4: Avviare il runtime</span><span class="sxs-lookup"><span data-stu-id="4d53d-160">Step 4 - Start the runtime</span></span>

<span data-ttu-id="4d53d-161">A differenza dell'API di hosting mscoree.h, descritta di seguito, le API CoreCLRHost.h avviano il runtime e creano l'AppDomain predefinito con una singola chiamata.</span><span class="sxs-lookup"><span data-stu-id="4d53d-161">Unlike the mscoree.h hosting API (described below), CoreCLRHost.h APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="4d53d-162">La funzione `coreclr_initialize` accetta un percorso di base, il nome e le proprietà descritte in precedenza e restituisce un handle all'host tramite il parametro `hostHandle`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-162">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="4d53d-163">Passaggio 5: Eseguire il codice gestito</span><span class="sxs-lookup"><span data-stu-id="4d53d-163">Step 5 - Run managed code!</span></span>

<span data-ttu-id="4d53d-164">Con il runtime avviato, l'host può chiamare il codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-164">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="4d53d-165">Questa operazione può essere eseguita in due modi diversi.</span><span class="sxs-lookup"><span data-stu-id="4d53d-165">This can be done in a couple of different ways.</span></span> <span data-ttu-id="4d53d-166">Il codice di esempio collegato a questa esercitazione usa la funzione `coreclr_create_delegate` per creare un delegato a un metodo gestito statico.</span><span class="sxs-lookup"><span data-stu-id="4d53d-166">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="4d53d-167">Questa API accetta come input il [nome dell'assembly](../../framework/app-domains/assembly-names.md), un nome di tipo qualificato dallo spazio dei nomi e il nome del metodo e restituisce un delegato che può essere usato per richiamare il metodo.</span><span class="sxs-lookup"><span data-stu-id="4d53d-167">This API takes the [assembly name](../../framework/app-domains/assembly-names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="4d53d-168">In questo esempio l'host può ora chiamare `managedDelegate` per eseguire il metodo `ManagedWorker.DoWork`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-168">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="4d53d-169">In alternativa è possibile usare la funzione `coreclr_execute_assembly` per avviare un file eseguibile gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-169">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="4d53d-170">Questa API accetta come parametri di input un percorso di assembly e una matrice di argomenti.</span><span class="sxs-lookup"><span data-stu-id="4d53d-170">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="4d53d-171">Carica l'assembly in questo percorso e ne richiama il metodo principale.</span><span class="sxs-lookup"><span data-stu-id="4d53d-171">It loads the assembly at that path and invokes its main method.</span></span>

```C++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="4d53d-172">Passaggio 6: Arrestare e pulire</span><span class="sxs-lookup"><span data-stu-id="4d53d-172">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="4d53d-173">Quando l'host ha infine terminato l'esecuzione del codice gestito, il runtime di .NET Core viene arrestato con `coreclr_shutdown` o `coreclr_shutdown_2`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-173">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="4d53d-174">Ricordarsi di scaricare la libreria CoreCLR usando `FreeLibrary` (in Windows) o `dlclose` (in Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="4d53d-174">Remember to unload the CoreCLR library using `FreeLibrary` (on Windows) or `dlclose` (on Linux/Mac).</span></span>

## <a name="create-a-host-using-mscoreeh"></a><span data-ttu-id="4d53d-175">Creare un host tramite Mscoree.h</span><span class="sxs-lookup"><span data-stu-id="4d53d-175">Create a host using Mscoree.h</span></span>

<span data-ttu-id="4d53d-176">Come accennato in precedenza, CoreClrHost.h è attualmente il metodo preferito per l'hosting del runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="4d53d-176">As mentioned previously, CoreClrHost.h is now the preferred method of hosting the .NET Core runtime.</span></span> <span data-ttu-id="4d53d-177">Ma è ancora possibile usare l'interfaccia `ICLRRuntimeHost4` se le interfacce CoreClrHost.h non sono sufficienti, ad esempio se sono necessari flag di avvio non standard o se è necessario un AppDomainManager nel dominio predefinito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-177">The `ICLRRuntimeHost4` interface can still be used, though, if the CoreClrHost.h interfaces aren't sufficient (if non-standard startup flags are needed, for example, or if an AppDomainManager is needed on the default domain).</span></span> <span data-ttu-id="4d53d-178">Queste istruzioni illustrano la procedura di hosting di .NET Core tramite mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="4d53d-178">These instructions will guide you through hosting .NET Core using mscoree.h.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="4d53d-179">Nota su mscoree.h</span><span class="sxs-lookup"><span data-stu-id="4d53d-179">A note about mscoree.h</span></span>
<span data-ttu-id="4d53d-180">L'interfaccia di hosting di .NET Core `ICLRRuntimeHost4` è definita in [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span><span class="sxs-lookup"><span data-stu-id="4d53d-180">The `ICLRRuntimeHost4` .NET Core hosting interface is defined in [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="4d53d-181">Una versione dell'intestazione di questo file (mscoree.h) a cui l'host dovrà fare riferimento viene prodotta tramite MIDL quando viene compilato il [runtime di .NET Core](https://github.com/dotnet/coreclr/).</span><span class="sxs-lookup"><span data-stu-id="4d53d-181">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/coreclr/) is built.</span></span> <span data-ttu-id="4d53d-182">Se non si vuole compilare il runtime di .NET Core, mscoree.h è disponibile anche come [intestazione precompilata](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) nel repository dotnet/coreclr.</span><span class="sxs-lookup"><span data-stu-id="4d53d-182">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) in the dotnet/coreclr repository.</span></span> <span data-ttu-id="4d53d-183">Le [istruzioni sulla compilazione del runtime di .NET Core](https://github.com/dotnet/coreclr#building-the-repository) sono disponibili nel relativo repository GitHub.</span><span class="sxs-lookup"><span data-stu-id="4d53d-183">[Instructions on building the .NET Core runtime](https://github.com/dotnet/coreclr#building-the-repository) can be found in its GitHub repository.</span></span>

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="4d53d-184">Passaggio 1: Identificare il punto di ingresso gestito</span><span class="sxs-lookup"><span data-stu-id="4d53d-184">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="4d53d-185">Dopo il riferimento alle intestazioni necessarie, ad esempio [mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) e stdio.h, una delle prime operazioni che devono essere eseguite da un host .NET Core consiste nell'individuare il punto di ingresso gestito da usare.</span><span class="sxs-lookup"><span data-stu-id="4d53d-185">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="4d53d-186">Nell'host di esempio questa operazione viene eseguita usando il primo argomento della riga di comando dell'host come percorso di un binario gestito di cui eseguire il metodo `main`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-186">In our sample host, this is done by just taking the first command line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](~/samples/core/hosting/HostWithMscoree/host.cpp#1)]

### <a name="step-2---find-and-load-coreclr"></a><span data-ttu-id="4d53d-187">Passaggio 2: Trovare e caricare CoreCLR</span><span class="sxs-lookup"><span data-stu-id="4d53d-187">Step 2 - Find and load CoreCLR</span></span>
<span data-ttu-id="4d53d-188">Le API del runtime di .NET Core sono in *CoreCLR.dll* in Windows.</span><span class="sxs-lookup"><span data-stu-id="4d53d-188">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="4d53d-189">Per ottenere l'interfaccia di hosting (`ICLRRuntimeHost4`), è necessario trovare e caricare *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="4d53d-189">To get our hosting interface (`ICLRRuntimeHost4`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="4d53d-190">L'host definisce una convenzione per l'individuazione di *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="4d53d-190">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="4d53d-191">Alcuni host prevedono che il file si trovi in un percorso noto del computer, ad esempio *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*.</span><span class="sxs-lookup"><span data-stu-id="4d53d-191">Some hosts expect the file to be present in a well-known machine-wide location (such as *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*).</span></span> <span data-ttu-id="4d53d-192">Altri prevedono che *CoreCLR.dll* venga caricato da un percorso successivo all'host o all'app da ospitare.</span><span class="sxs-lookup"><span data-stu-id="4d53d-192">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="4d53d-193">Altri ancora usano una variabile di ambiente per trovare la libreria.</span><span class="sxs-lookup"><span data-stu-id="4d53d-193">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="4d53d-194">In Linux o Mac la libreria di runtime principale è rispettivamente *libcoreclr.so* o *libcoreclr.dylib*.</span><span class="sxs-lookup"><span data-stu-id="4d53d-194">On Linux or Mac, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="4d53d-195">L'host di esempio esegue il probe in alcuni percorsi comuni di *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="4d53d-195">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="4d53d-196">Dopo essere stata individuata, la libreria deve essere caricata tramite `LoadLibrary` (o `dlopen` in Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="4d53d-196">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/Mac).</span></span>

[!code-cpp[NetCoreHost#2](~/samples/core/hosting/HostWithMscoree/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost4-instance"></a><span data-ttu-id="4d53d-197">Passaggio 3: Ottenere un'istanza ICLRRuntimeHost4</span><span class="sxs-lookup"><span data-stu-id="4d53d-197">Step 3 - Get an ICLRRuntimeHost4 Instance</span></span>
<span data-ttu-id="4d53d-198">L'interfaccia di hosting `ICLRRuntimeHost4` viene recuperata chiamando `GetProcAddress` (o `dlsym` in Linux/Mac) in `GetCLRRuntimeHost` e quindi richiamando la funzione.</span><span class="sxs-lookup"><span data-stu-id="4d53d-198">The `ICLRRuntimeHost4` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/Mac) on `GetCLRRuntimeHost`, and then invoking that function.</span></span>

[!code-cpp[NetCoreHost#3](~/samples/core/hosting/HostWithMscoree/host.cpp#3)]

### <a name="step-4---set-startup-flags-and-start-the-runtime"></a><span data-ttu-id="4d53d-199">Passaggio 4: Impostare i flag di avvio e avviare il runtime</span><span class="sxs-lookup"><span data-stu-id="4d53d-199">Step 4 - Set startup flags and start the runtime</span></span>
<span data-ttu-id="4d53d-200">Con un `ICLRRuntimeHost4` disponibile, è ora possibile specificare flag di avvio del runtime e avviare il runtime.</span><span class="sxs-lookup"><span data-stu-id="4d53d-200">With an `ICLRRuntimeHost4` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="4d53d-201">I flag di avvio determinano il Garbage Collector (GC) da usare (simultaneo o server), l'uso di AppDomain singoli o multipli e i criteri di ottimizzazione del caricatore da usare per il caricamento di assembly indipendente dal dominio.</span><span class="sxs-lookup"><span data-stu-id="4d53d-201">Startup flags determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](~/samples/core/hosting/HostWithMscoree/host.cpp#4)]

<span data-ttu-id="4d53d-202">Il runtime viene avviato con una chiamata alla funzione `Start`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-202">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="4d53d-203">Passaggio 5: Preparazione delle impostazioni dell'AppDomain</span><span class="sxs-lookup"><span data-stu-id="4d53d-203">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="4d53d-204">Dopo aver avviato il runtime, sarà necessario impostare un AppDomain.</span><span class="sxs-lookup"><span data-stu-id="4d53d-204">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="4d53d-205">Poiché quando si crea un AppDomain .NET sono presenti numerose opzioni da specificare, è necessario preparare tali impostazioni.</span><span class="sxs-lookup"><span data-stu-id="4d53d-205">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="4d53d-206">I flag AppDomain specificano i comportamenti di AppDomain correlati alla sicurezza e all'interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="4d53d-206">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="4d53d-207">Gli host Silverlight precedenti usavano queste impostazioni per creare il codice utente mediante sandbox, mentre gli host .NET Core più recenti eseguono il codice utente come totalmente attendibile e abilitano l'interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="4d53d-207">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](~/samples/core/hosting/HostWithMscoree/host.cpp#5)]

<span data-ttu-id="4d53d-208">Dopo aver deciso quali flag AppDomain usare, è necessario definire le proprietà dell'AppDomain.</span><span class="sxs-lookup"><span data-stu-id="4d53d-208">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="4d53d-209">Le proprietà sono coppie chiave/valore delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="4d53d-209">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="4d53d-210">Molte delle proprietà riguardano la modalità con la quale l'AppDomain caricherà gli assembly.</span><span class="sxs-lookup"><span data-stu-id="4d53d-210">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="4d53d-211">Le proprietà di AppDomain comuni includono:</span><span class="sxs-lookup"><span data-stu-id="4d53d-211">Common AppDomain properties include:</span></span>

* <span data-ttu-id="4d53d-212">`TRUSTED_PLATFORM_ASSEMBLIES` Elenco di percorsi di assembly (delimitato da `;` in Windows e `:` in Linux/Mac) ai quali l'AppDomain deve dare priorità di caricamento e assegnare attendibilità totale, anche in domini parzialmente attendibili.</span><span class="sxs-lookup"><span data-stu-id="4d53d-212">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by `;` on Windows and `:` on Linux/Mac) which the AppDomain should prioritize loading and give full trust to (even in partially-trusted domains).</span></span> <span data-ttu-id="4d53d-213">Questo elenco deve contenere assembly 'Framework' e altri moduli attendibili, analogamente a GAC negli scenari .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4d53d-213">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="4d53d-214">Alcuni host inseriranno le librerie accanto a *coreclr.dll* nell'elenco, mentre altri avranno manifesti hardcoded che elencano gli assembly attendibili per i propri scopi.</span><span class="sxs-lookup"><span data-stu-id="4d53d-214">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="4d53d-215">`APP_PATHS` Elenco di percorsi in cui eseguire il probe se un assembly non viene trovato nell'elenco degli assembly di piattaforma attendibili (TPA).</span><span class="sxs-lookup"><span data-stu-id="4d53d-215">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="4d53d-216">Poiché l'host ha un maggiore controllo su quali assembly vengono caricati tramite l'elenco TPA, è consigliabile che gli host determinino gli assembly che prevedono di caricare e li elenchino in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-216">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="4d53d-217">Se è necessaria l'esecuzione del probe al runtime, tuttavia, questa proprietà può abilitare tale scenario.</span><span class="sxs-lookup"><span data-stu-id="4d53d-217">If probing at runtime is needed, however, this property can enable that scenario.</span></span>
*  <span data-ttu-id="4d53d-218">`APP_NI_PATHS` Elenco molto simile ad APP_PATHS ma che deve includere i percorsi in cui verrà eseguito il probe delle immagini native.</span><span class="sxs-lookup"><span data-stu-id="4d53d-218">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
*  <span data-ttu-id="4d53d-219">`NATIVE_DLL_SEARCH_DIRECTORIES` Questa proprietà è un elenco di percorsi in cui il caricatore esegue il probe quando cerca DLL native chiamate tramite p/invoke.</span><span class="sxs-lookup"><span data-stu-id="4d53d-219">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
*  <span data-ttu-id="4d53d-220">`PLATFORM_RESOURCE_ROOTS` Questo elenco include i percorsi in cui eseguire il probe di assembly satelliti di risorse in sottodirectory specifiche delle impostazioni cultura.</span><span class="sxs-lookup"><span data-stu-id="4d53d-220">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>

<span data-ttu-id="4d53d-221">In questo [host di esempio semplice](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree) queste proprietà sono impostate come segue:</span><span class="sxs-lookup"><span data-stu-id="4d53d-221">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](~/samples/core/hosting/HostWithMscoree/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="4d53d-222">Passaggio 6: Creare l'AppDomain</span><span class="sxs-lookup"><span data-stu-id="4d53d-222">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="4d53d-223">Dopo aver preparato tutti i flag e le proprietà AppDomain, è possibile usare `ICLRRuntimeHost4::CreateAppDomainWithManager` per impostare l'AppDomain.</span><span class="sxs-lookup"><span data-stu-id="4d53d-223">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost4::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="4d53d-224">Questa funzione accetta facoltativamente un nome di assembly completo e un nome di tipo da usare come gestore AppDomain del dominio.</span><span class="sxs-lookup"><span data-stu-id="4d53d-224">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="4d53d-225">Un gestore AppDomain può consentire a un host di controllare alcuni aspetti del comportamento dell'AppDomain e può offrire i punti di ingresso per l'avvio di codice gestito se l'host non intende richiamare il codice utente direttamente.</span><span class="sxs-lookup"><span data-stu-id="4d53d-225">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>

[!code-cpp[NetCoreHost#7](~/samples/core/hosting/HostWithMscoree/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="4d53d-226">Passaggio 7: Eseguire il codice gestito</span><span class="sxs-lookup"><span data-stu-id="4d53d-226">Step 7 - Run managed code!</span></span>
<span data-ttu-id="4d53d-227">Con un AppDomain attivo e in esecuzione, l'host può ora avviare l'esecuzione del codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-227">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="4d53d-228">Il modo più semplice per eseguire questa operazione consiste nell'usare `ICLRRuntimeHost4::ExecuteAssembly` per richiamare un metodo del punto di ingresso dell'assembly gestito.</span><span class="sxs-lookup"><span data-stu-id="4d53d-228">The easiest way to do this is to use `ICLRRuntimeHost4::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="4d53d-229">Si noti che questa funzione funziona solo in scenari con dominio singolo.</span><span class="sxs-lookup"><span data-stu-id="4d53d-229">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](~/samples/core/hosting/HostWithMscoree/host.cpp#8)]

<span data-ttu-id="4d53d-230">Se `ExecuteAssembly` non soddisfa le esigenze dell'host, un'altra opzione consiste nell'usare `CreateDelegate` per creare un puntatore funzione a un metodo gestito statico.</span><span class="sxs-lookup"><span data-stu-id="4d53d-230">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="4d53d-231">Questa operazione richiede che l'host conosca la firma del metodo chiamato per poter creare il tipo di puntatore funzione ma offre agli host la flessibilità di richiamare codice diverso da un punto di ingresso dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4d53d-231">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span> <span data-ttu-id="4d53d-232">Il nome dell'assembly specificato nel secondo parametro è il [nome completo dell'assembly gestito](../../framework/app-domains/assembly-names.md) della raccolta da caricare.</span><span class="sxs-lookup"><span data-stu-id="4d53d-232">The assembly name provided in the second parameter is the [full managed assembly name](../../framework/app-domains/assembly-names.md) of the library to load.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
    domainId,
    L"HW, Version=1.0.0.0, Culture=neutral", // Target managed assembly
    L"ConsoleApplication.Program",           // Target managed type
    L"Main",                                 // Target entry point (static method)
    (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="4d53d-233">Passaggio 8: Pulire</span><span class="sxs-lookup"><span data-stu-id="4d53d-233">Step 8 - Clean up</span></span>
<span data-ttu-id="4d53d-234">È necessario infine che l'host esegua una pulizia scaricando gli AppDomain, interrompendo il runtime e rilasciando il riferimento `ICLRRuntimeHost4`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-234">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost4` reference.</span></span>

[!code-cpp[NetCoreHost#9](~/samples/core/hosting/HostWithMscoree/host.cpp#9)]

## <a name="conclusion"></a><span data-ttu-id="4d53d-235">Conclusione</span><span class="sxs-lookup"><span data-stu-id="4d53d-235">Conclusion</span></span>
<span data-ttu-id="4d53d-236">Dopo aver compilato l'host, è possibile testarlo eseguendolo dalla riga di comando e passando gli argomenti previsti dall'host, ad esempio l'app gestita da eseguire per l'host di esempio mscoree.</span><span class="sxs-lookup"><span data-stu-id="4d53d-236">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects (like the managed app to run for the mscoree example host).</span></span> <span data-ttu-id="4d53d-237">Quando si specifica l'app .NET Core che deve essere eseguita dall'host, assicurarsi di usare il file DLL prodotto da `dotnet build`.</span><span class="sxs-lookup"><span data-stu-id="4d53d-237">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="4d53d-238">Gli eseguibili (file con estensione exe) prodotti da `dotnet publish` per applicazioni autonome e complete sono in realtà l'host .NET Core predefinito, in modo che l'app possa essere avviata direttamente dalla riga di comando nei principali scenari. Il codice utente viene compilato in un file DLL con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="4d53d-238">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="4d53d-239">Se si verifica un malfunzionamento inizialo, verificare che *coreclr.dll* sia disponibile nel percorso previsto dall'host, che tutte le librerie Framework necessarie siano incluse nell'elenco TPA e che il numero di bit (32 o 64) di CoreCLR corrisponda alla modalità di compilazione dell'host.</span><span class="sxs-lookup"><span data-stu-id="4d53d-239">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32- or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="4d53d-240">Sebbene rappresenti uno scenario avanzato che molti sviluppatori non richiedono, l'hosting del runtime di .NET Core può essere molto utile per gli sviluppatori che devono avviare codice gestito da un processo nativo o che necessitano di maggior controllo sul comportamento del runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="4d53d-240">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>
