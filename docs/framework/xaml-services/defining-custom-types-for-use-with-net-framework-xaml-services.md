---
title: Definizione di tipi personalizzati da utilizzare con i servizi XAML di .NET Framework
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/23/2019
ms.locfileid: "61971951"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="3628e-102">Definizione di tipi personalizzati da utilizzare con i servizi XAML di .NET Framework</span><span class="sxs-lookup"><span data-stu-id="3628e-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="3628e-103">Quando si definiscono tipi personalizzati che sono oggetti business o i tipi che non è una dipendenza su Framework specifici, esistono alcune procedure consigliate per XAML è possibile seguire.</span><span class="sxs-lookup"><span data-stu-id="3628e-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="3628e-104">Se si seguono queste procedure, dei servizi XAML di .NET Framework e relativi reader XAML e writer XAML può individuare le caratteristiche XAML del tipo in uso e assegnargli rappresentazione appropriata in un flusso di nodi XAML usando il sistema di tipi XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="3628e-105">In questo argomento descrive le procedure consigliate per le definizioni dei tipi, le definizioni dei membri e assegnazione di attributi CLR di tipi o membri.</span><span class="sxs-lookup"><span data-stu-id="3628e-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="3628e-106">Modelli di costruttore e definizioni di tipi per XAML</span><span class="sxs-lookup"><span data-stu-id="3628e-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="3628e-107">Per creare un'istanza come elemento oggetto in XAML, una classe personalizzata deve soddisfare i requisiti seguenti:</span><span class="sxs-lookup"><span data-stu-id="3628e-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="3628e-108">La classe personalizzata deve essere pubblica e deve esporre un costruttore pubblico (senza parametri) predefinito.</span><span class="sxs-lookup"><span data-stu-id="3628e-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="3628e-109">Per alcune note riguardanti le strutture, vedere la sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="3628e-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="3628e-110">La classe personalizzata non deve essere una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="3628e-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="3628e-111">Aggiuntivo "dot" nel percorso del nome completo rende ambiguo la divisione di spazio dei nomi di classe e interferisce con altre funzionalità XAML, ad esempio le proprietà associate.</span><span class="sxs-lookup"><span data-stu-id="3628e-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="3628e-112">Se è possibile creare istanze di un oggetto come elemento oggetto, l'oggetto creato è riempire il form elemento di proprietà di qualsiasi proprietà che accettano l'oggetto come relativo tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="3628e-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="3628e-113">È comunque possibile fornire valori dell'oggetto per i tipi che non soddisfano questi criteri, se si abilita un convertitore di valori.</span><span class="sxs-lookup"><span data-stu-id="3628e-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="3628e-114">Per altre informazioni, vedere [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="3628e-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="3628e-115">Strutture</span><span class="sxs-lookup"><span data-stu-id="3628e-115">Structures</span></span>  
 <span data-ttu-id="3628e-116">Le strutture sono sempre in grado di costruire in XAML, per definizione di CLR.</span><span class="sxs-lookup"><span data-stu-id="3628e-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="3628e-117">Questo avviene perché un compilatore CLR crea implicitamente un costruttore predefinito per una struttura.</span><span class="sxs-lookup"><span data-stu-id="3628e-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="3628e-118">Questo costruttore inizializza tutti i valori di proprietà sui valori predefiniti.</span><span class="sxs-lookup"><span data-stu-id="3628e-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="3628e-119">In alcuni casi, il comportamento di costruzione predefinita per una struttura non è consigliabile.</span><span class="sxs-lookup"><span data-stu-id="3628e-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="3628e-120">È possibile perché la struttura è destinata a inserire valori e funzioni a livello concettuale come un'unione.</span><span class="sxs-lookup"><span data-stu-id="3628e-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="3628e-121">Come un'unione, i valori contenuti potrebbero avere interpretazioni si escludono a vicenda e di conseguenza, nessuna delle relative proprietà possono essere impostata.</span><span class="sxs-lookup"><span data-stu-id="3628e-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="3628e-122">Un esempio di tale struttura nel vocabolario WPF è <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="3628e-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="3628e-123">Tali strutture devono implementare un convertitore di tipi in modo che i valori possono essere espressi sotto forma di attributo tramite convenzioni di stringa che creano le interpretazioni o modalità diverse dei valori di struttura.</span><span class="sxs-lookup"><span data-stu-id="3628e-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="3628e-124">La struttura deve anche esporre un comportamento simile per la costruzione del codice tramite un costruttore non predefinito.</span><span class="sxs-lookup"><span data-stu-id="3628e-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="3628e-125">Interfacce</span><span class="sxs-lookup"><span data-stu-id="3628e-125">Interfaces</span></span>  
 <span data-ttu-id="3628e-126">Le interfacce possono essere utilizzate come tipi sottostanti dei membri.</span><span class="sxs-lookup"><span data-stu-id="3628e-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="3628e-127">Il sistema di tipi XAML controlla l'elenco può essere assegnato e si aspetta che l'oggetto fornito come valore può essere assegnato all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="3628e-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="3628e-128">Non vi è alcun concetto di modalità di presentazione dell'interfaccia come tipo XAML fino a quando un tipo assegnabile rilevante supportino i requisiti di costruzione di XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="3628e-129">Metodi factory</span><span class="sxs-lookup"><span data-stu-id="3628e-129">Factory Methods</span></span>  
 <span data-ttu-id="3628e-130">I metodi factory sono una funzionalità di XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="3628e-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="3628e-131">Modificare il principio XAML che gli oggetti devono avere costruttori predefiniti.</span><span class="sxs-lookup"><span data-stu-id="3628e-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="3628e-132">I metodi factory non sono documentati in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="3628e-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="3628e-133">Visualizzare [direttiva X:FactoryMethod](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="3628e-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="3628e-134">Enumerazioni</span><span class="sxs-lookup"><span data-stu-id="3628e-134">Enumerations</span></span>  
 <span data-ttu-id="3628e-135">Le enumerazioni dispongono di comportamento di conversione di tipo nativo di XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="3628e-136">I nomi delle costanti di enumerazione specificati nel XAML vengono risolti in base al tipo di enumerazione sottostante e restituisce il valore di enumerazione a un writer di oggetti XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="3628e-137">XAML supporta l'utilizzo di flag di stile per le enumerazioni con <xref:System.FlagsAttribute> applicato.</span><span class="sxs-lookup"><span data-stu-id="3628e-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="3628e-138">Per altre informazioni, vedere [XAML descrizione dettagliata della sintassi](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="3628e-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="3628e-139">([XAML descrizione dettagliata della sintassi](../wpf/advanced/xaml-syntax-in-detail.md) è stata scritta per il gruppo di destinatari WPF, ma la maggior parte delle informazioni in questo argomento sono rilevanti per XAML che non è specifico per un particolare framework di implementazione.)</span><span class="sxs-lookup"><span data-stu-id="3628e-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="3628e-140">Definizioni dei membri</span><span class="sxs-lookup"><span data-stu-id="3628e-140">Member Definitions</span></span>  
 <span data-ttu-id="3628e-141">Tipi possono definire i membri per l'utilizzo XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="3628e-142">È possibile che i tipi che definiscono i membri che possono essere utilizzati con XAML anche se quel tipo specifico non è utilizzabile con XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="3628e-143">Ciò è possibile a causa dell'ereditarietà di CLR.</span><span class="sxs-lookup"><span data-stu-id="3628e-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="3628e-144">Purché alcuni tipo che eredita il membro supporta l'utilizzo XAML come tipo e il membro supporta l'utilizzo di XAML per il relativo tipo sottostante o presenta una sintassi XAML nativa disponibile, tale membro è utilizzabile con XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="3628e-145">Proprietà</span><span class="sxs-lookup"><span data-stu-id="3628e-145">Properties</span></span>  
 <span data-ttu-id="3628e-146">Se si definiscono proprietà come proprietà CLR pubblica usando CLR tipico `get` e `set` modelli di funzione di accesso e parole chiave appropriata per la lingua, il sistema di tipi XAML può segnalare la proprietà come un membro con le informazioni appropriate previste <xref:System.Xaml.XamlMember> proprietà, ad esempio <xref:System.Xaml.XamlMember.IsReadPublic%2A> e <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="3628e-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="3628e-147">Le proprietà specifiche è possono abilitare una sintassi del testo applicando <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="3628e-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="3628e-148">Per altre informazioni, vedere [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="3628e-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="3628e-149">In assenza di una sintassi del testo o di conversione nativa XAML e in assenza di un'ulteriore riferimento indiretto, ad esempio un utilizzo dell'estensione di markup, il tipo di una proprietà (<xref:System.Xaml.XamlMember.TargetType%2A> in XAML il sistema di tipi) deve essere in grado di restituire un'istanza a un writer di oggetti XAML, considerando la t tipo arget come tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="3628e-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="3628e-150">Se si usa XAML 2009 [X:Reference Markup Extension](x-reference-markup-extension.md) possono essere usati per fornire i valori se non vengono soddisfatte le considerazioni precedenti, tuttavia, che è più di un problema di utilizzo rispetto a un problema di definizione del tipo.</span><span class="sxs-lookup"><span data-stu-id="3628e-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="3628e-151">Eventi</span><span class="sxs-lookup"><span data-stu-id="3628e-151">Events</span></span>  
 <span data-ttu-id="3628e-152">Se si definiscono gli eventi come un evento pubblico CLR, il sistema di tipi XAML può segnalare l'evento come un membro con <xref:System.Xaml.XamlMember.IsEvent%2A> come `true`.</span><span class="sxs-lookup"><span data-stu-id="3628e-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="3628e-153">Collegare i gestori di eventi non è nell'ambito di funzionalità di servizi XAML di .NET Framework; Questo è lasciato a Framework specifici e implementazioni.</span><span class="sxs-lookup"><span data-stu-id="3628e-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="3628e-154">Metodi</span><span class="sxs-lookup"><span data-stu-id="3628e-154">Methods</span></span>  
 <span data-ttu-id="3628e-155">Il codice inline per metodi non è una funzionalità XAML predefinito.</span><span class="sxs-lookup"><span data-stu-id="3628e-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="3628e-156">Nella maggior parte dei casi non si direttamente fa riferimento a membri del metodo da XAML e il ruolo di metodi in XAML è solo per fornire supporto per specifici modelli XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="3628e-157">[Direttiva X:FactoryMethod](x-factorymethod-directive.md) è un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3628e-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="3628e-158">Campi</span><span class="sxs-lookup"><span data-stu-id="3628e-158">Fields</span></span>  
 <span data-ttu-id="3628e-159">Linee guida di progettazione CLR scoraggiare i campi non statici.</span><span class="sxs-lookup"><span data-stu-id="3628e-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="3628e-160">Per i campi statici, è possibile accedere i valori dei campi statici solo attraverso [estensione di Markup X:Static](x-static-markup-extension.md); in questo caso non si sta eseguendo alcuna operazione speciale nella definizione del CLR di un campo per esporre [X:Static](x-static-markup-extension.md) utilizzi.</span><span class="sxs-lookup"><span data-stu-id="3628e-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="3628e-161">Membri associabili</span><span class="sxs-lookup"><span data-stu-id="3628e-161">Attachable Members</span></span>  
 <span data-ttu-id="3628e-162">I membri associabili sono esposte a XAML tramite un modello di metodo della funzione di accesso su un tipo di definizione.</span><span class="sxs-lookup"><span data-stu-id="3628e-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="3628e-163">Tipo di definizione stesso non è necessario per poter essere usato per XAML come oggetto.</span><span class="sxs-lookup"><span data-stu-id="3628e-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="3628e-164">In effetti, un modello comune consiste nel dichiarare una classe di servizio con ruolo proprietario membro associabile e implementare i comportamenti correlati, ma anche non servire alcuna altra funzione, ad esempio una rappresentazione dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="3628e-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="3628e-165">Per le sezioni seguenti, il segnaposto *PropertyName* rappresenta il nome del membro associabile.</span><span class="sxs-lookup"><span data-stu-id="3628e-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="3628e-166">Tale nome deve essere valido nella [grammatica XamlName](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="3628e-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="3628e-167">Prestare attenzione dei conflitti di nomi tra questi modelli e altri metodi di un tipo.</span><span class="sxs-lookup"><span data-stu-id="3628e-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="3628e-168">Se esiste un membro che corrisponde a uno dei modelli, si può essere interpretato come un percorso di utilizzo del membro associabile da un processore XAML anche se non si intende.</span><span class="sxs-lookup"><span data-stu-id="3628e-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="3628e-169">Funzione di accesso GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="3628e-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="3628e-170">La firma per la funzione di accesso `Get`*NomeProprietà* deve essere:</span><span class="sxs-lookup"><span data-stu-id="3628e-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="3628e-171">`public static object Get` *PropertyName* `(object` `target` `)`</span><span class="sxs-lookup"><span data-stu-id="3628e-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="3628e-172">L'oggetto `target` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="3628e-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="3628e-173">È possibile utilizzare questo per definire l'ambito di utilizzo del membro associabile; gli utilizzi rientrano nell'ambito desiderato genererà le eccezioni di cast non valido che vengono quindi replicate da un errore di analisi XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="3628e-174">Il nome del parametro `target` non è un requisito, ma è denominato `target` per convenzione nella maggior parte delle implementazioni.</span><span class="sxs-lookup"><span data-stu-id="3628e-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="3628e-175">Il valore restituito può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="3628e-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="3628e-176">Per supportare un <xref:System.ComponentModel.TypeConverter> sintassi del testo abilitata per l'utilizzo dell'attributo del membro associabile, applicare <xref:System.ComponentModel.TypeConverterAttribute> per il `Get` *PropertyName* della funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="3628e-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="3628e-177">Applicazione al `get` anziché il `set` può sembrare non intuitiva; tuttavia, questa convenzione può supportare il concetto di sola lettura i membri associabili serializzabili, che risulta utile negli scenari di progettazione.</span><span class="sxs-lookup"><span data-stu-id="3628e-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="3628e-178">La funzione di accesso SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="3628e-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="3628e-179">La firma per il Set*PropertyName* della funzione di accesso deve essere:</span><span class="sxs-lookup"><span data-stu-id="3628e-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="3628e-180">`public static void Set` *NomeProprietà* `(object` `target` `, object` `value` `)`</span><span class="sxs-lookup"><span data-stu-id="3628e-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="3628e-181">Il `target` oggetto può essere specificato come un tipo più specifico nell'implementazione, con lo stesso per la logica e conseguenze come descritto nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="3628e-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="3628e-182">L'oggetto `value` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="3628e-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="3628e-183">Tenere presente che il valore per questo metodo è l'input proveniente dall'uso di XAML, in genere sotto forma di attributo.</span><span class="sxs-lookup"><span data-stu-id="3628e-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="3628e-184">Dalla forma di attributo deve essere presente il supporto di convertitore di tipi di valore per una sintassi del testo e attributo il `Get` *NomeProprietà* della funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="3628e-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="3628e-185">Archivi dei membri associabili</span><span class="sxs-lookup"><span data-stu-id="3628e-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="3628e-186">I metodi della funzione di accesso in genere non sono sufficienti per fornire un mezzo per inserire i valori del membro associabile in un oggetto grafico, o per recuperare i valori fuori dall'oggetto grafico e serializzarli nel modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="3628e-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="3628e-187">Per fornire questa funzionalità, il `target` gli oggetti nelle firme della funzione di accesso precedente devono essere in grado di archiviare i valori.</span><span class="sxs-lookup"><span data-stu-id="3628e-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="3628e-188">Il meccanismo di archiviazione deve essere coerenza con il principio di membro associabile che il membro è associabile alle destinazioni in cui il membro associabile non è nell'elenco dei membri.</span><span class="sxs-lookup"><span data-stu-id="3628e-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="3628e-189">Servizi XAML di .NET framework fornisce una tecnica di implementazione per membro associabile archivi tramite le API <xref:System.Xaml.IAttachedPropertyStore> e <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="3628e-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="3628e-190"><xref:System.Xaml.IAttachedPropertyStore> viene usato dai writer XAML per individuare l'implementazione dell'archivio e deve essere implementata nel tipo che è il `target` delle funzioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="3628e-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="3628e-191">Il metodo statico <xref:System.Xaml.AttachablePropertyServices> API vengono utilizzate all'interno del corpo delle funzioni di accesso e fare riferimento al membro associabile da relativo <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="3628e-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="3628e-192">Attributi CLR correlati a XAML</span><span class="sxs-lookup"><span data-stu-id="3628e-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="3628e-193">Corretta attribuzione di tipi, membri e gli assembly è importante in ordine al report informazioni sul sistema di tipo XAML ai servizi XAML di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3628e-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="3628e-194">Ciò è rilevante se si prevede di tipi per l'uso con i sistemi XAML direttamente basate su servizi XAML di .NET Framework XAML reader e writer XAML, o se si definisce o si usa un framework che usano XAML basato su tali reader XAML e writer XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="3628e-195">Per un elenco di ciascun attributo XAML correlati che sono rilevante per il supporto XAML di tipi personalizzati, vedere [Related attributi CLR per tipi e librerie personalizzati](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="3628e-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="3628e-196">Utilizzo</span><span class="sxs-lookup"><span data-stu-id="3628e-196">Usage</span></span>  
 <span data-ttu-id="3628e-197">Utilizzo di tipi personalizzati è necessario che l'autore del markup deve eseguire il mapping di un prefisso per l'assembly e dello spazio dei nomi CLR che contengono il tipo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="3628e-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="3628e-198">Questa procedura non è documentata in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="3628e-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="3628e-199">Livello di accesso</span><span class="sxs-lookup"><span data-stu-id="3628e-199">Access Level</span></span>  
 <span data-ttu-id="3628e-200">XAML fornisce un modo per caricare e creare istanze di tipi che hanno un `internal` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="3628e-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="3628e-201">Questa funzionalità viene fornita in modo che il codice utente possa definire tipi personalizzati e quindi creare un'istanza di tali classi dal markup che fa anche parte dell'ambito stesso codice utente.</span><span class="sxs-lookup"><span data-stu-id="3628e-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="3628e-202">Un esempio di WPF è ogni volta che il codice utente definisce una <xref:System.Windows.Controls.UserControl> inteso come un modo per effettuare il refactoring di un comportamento dell'interfaccia utente, ma non come parte di qualsiasi meccanismo di estensione possibili che potrà essere in cui è inclusa la dichiarazione della classe di supporto con `public` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="3628e-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="3628e-203">Questo tipo una <xref:System.Windows.Controls.UserControl> possono essere dichiarate con `internal` accedere se il codice sottostante viene compilato nello stesso assembly da cui viene fatto riferimento come un tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="3628e-204">Per un'applicazione che carica XAML con attendibilità totale e utilizza <xref:System.Xaml.XamlObjectWriter>, il caricamento delle classi con `internal` a livello di accesso è sempre abilitato.</span><span class="sxs-lookup"><span data-stu-id="3628e-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="3628e-205">Per un'applicazione che esegue il caricamento di XAML con attendibilità parziale, è possibile controllare le caratteristiche a livello di accesso usando il <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="3628e-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="3628e-206">Inoltre, i meccanismi di rinvio (ad esempio, il sistema di modelli WPF) devono essere in grado di propagare le autorizzazioni a livello di accesso e conservarli per le valutazioni di fase di esecuzione finale; Questa operazione viene gestita internamente passando il <xref:System.Xaml.Permissions.XamlAccessLevel> informazioni.</span><span class="sxs-lookup"><span data-stu-id="3628e-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="3628e-207">Implementazione di WPF</span><span class="sxs-lookup"><span data-stu-id="3628e-207">WPF Implementation</span></span>  
 <span data-ttu-id="3628e-208">WPF XAML Usa un modello di accesso parzialmente attendibile dove se BAML viene caricato con attendibilità parziale, l'accesso è limitato a <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> per l'assembly che rappresenta l'origine BAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="3628e-209">Per il differimento, WPF utilizza <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> come un meccanismo per passare le informazioni a livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="3628e-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="3628e-210">Nella terminologia di WPF XAML, un *tipo interno* è un tipo definito dall'assembly stesso che include anche il riferimento XAML.</span><span class="sxs-lookup"><span data-stu-id="3628e-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="3628e-211">Questo tipo può essere mappato mediante uno spazio dei nomi XAML viene deliberatamente omesso assembly = parte di un mapping, ad esempio, `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="3628e-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="3628e-212">Se BAML fa riferimento a un tipo interno e che disponga di tipo `internal` accedere al livello, verrà generato un `GeneratedInternalTypeHelper` classe per l'assembly.</span><span class="sxs-lookup"><span data-stu-id="3628e-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="3628e-213">Se si desidera evitare `GeneratedInternalTypeHelper`, è necessario utilizzare `public` , livello di accesso deve prendere in considerazione la classe rilevante in un assembly separato e rendere tale assembly dipendente.</span><span class="sxs-lookup"><span data-stu-id="3628e-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3628e-214">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="3628e-214">See also</span></span>

- [<span data-ttu-id="3628e-215">Attributi CLR correlati a XAML per tipi e librerie personalizzati</span><span class="sxs-lookup"><span data-stu-id="3628e-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="3628e-216">Servizi XAML</span><span class="sxs-lookup"><span data-stu-id="3628e-216">XAML Services</span></span>](index.md)
