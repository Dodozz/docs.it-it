---
title: Classi
description: Informazioni su come F# le classi sono tipi che rappresentano oggetti che possono avere proprietà, metodi ed eventi.
ms.date: 05/16/2016
ms.openlocfilehash: a233fea538274216db3c6751f6fbabbf70cc2841
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/15/2019
ms.locfileid: "65645522"
---
# <a name="classes"></a><span data-ttu-id="98172-103">Classi</span><span class="sxs-lookup"><span data-stu-id="98172-103">Classes</span></span>

<span data-ttu-id="98172-104">*Le classi* sono tipi che rappresentano oggetti che possono avere proprietà, metodi ed eventi.</span><span class="sxs-lookup"><span data-stu-id="98172-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="98172-105">Sintassi</span><span class="sxs-lookup"><span data-stu-id="98172-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="98172-106">Note</span><span class="sxs-lookup"><span data-stu-id="98172-106">Remarks</span></span>

<span data-ttu-id="98172-107">Le classi rappresentano la descrizione fondamentale dei tipi di oggetto .NET. la classe è il concetto di tipo primario che supporta la programmazione orientata agli oggetti in F#.</span><span class="sxs-lookup"><span data-stu-id="98172-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="98172-108">Nella sintassi precedente, il `type-name` qualsiasi identificatore valido.</span><span class="sxs-lookup"><span data-stu-id="98172-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="98172-109">Il `type-params` vengono descritti i parametri di tipo generico facoltativo.</span><span class="sxs-lookup"><span data-stu-id="98172-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="98172-110">È costituito da nomi di parametro di tipo e vincoli racchiuso tra parentesi angolari (`<` e `>`).</span><span class="sxs-lookup"><span data-stu-id="98172-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="98172-111">Per altre informazioni, vedere [Generics](generics/index.md) e [vincoli](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="98172-111">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="98172-112">Il `parameter-list` vengono descritti i parametri del costruttore.</span><span class="sxs-lookup"><span data-stu-id="98172-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="98172-113">Il modificatore di accesso prima si riferisce il tipo. il secondo riguarda il costruttore primario.</span><span class="sxs-lookup"><span data-stu-id="98172-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="98172-114">In entrambi i casi, il valore predefinito è `public`.</span><span class="sxs-lookup"><span data-stu-id="98172-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="98172-115">Specificare la classe base per una classe usando la `inherit` (parola chiave).</span><span class="sxs-lookup"><span data-stu-id="98172-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="98172-116">È necessario fornire argomenti, racchiusi tra parentesi, per il costruttore di classe di base.</span><span class="sxs-lookup"><span data-stu-id="98172-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="98172-117">Si dichiara i campi o che sono locali rispetto alla classe con valori di funzione `let` associazioni ed è necessario seguire le regole generali per `let` associazioni.</span><span class="sxs-lookup"><span data-stu-id="98172-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="98172-118">Il `do-bindings` sezione include il codice da eseguire durante la costruzione di oggetti.</span><span class="sxs-lookup"><span data-stu-id="98172-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="98172-119">Il `member-list` include costruttori aggiuntivi, istanza e le dichiarazioni di metodo statico, le dichiarazioni di interfaccia, associazioni astratte e dichiarazioni di proprietà ed eventi.</span><span class="sxs-lookup"><span data-stu-id="98172-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="98172-120">Questi elementi sono descritti [membri](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="98172-120">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="98172-121">Il `identifier` che viene usato con l'opzione facoltativa `as` (parola chiave) fornisce un nome per la variabile di istanza oppure autoidentificatore, che può essere utilizzato nella definizione del tipo per fare riferimento all'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="98172-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="98172-122">Per altre informazioni, vedere la sezione autoidentificatori più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="98172-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="98172-123">Le parole chiave `class` e `end` che contrassegna l'inizio e fine della definizione sono facoltativi.</span><span class="sxs-lookup"><span data-stu-id="98172-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="98172-124">Si escludono a vicenda tipi ricorsiva, che sono tipi che fanno riferimento a altro, vengono uniti dall'operatore di `and` (parola chiave) come funzioni ricorsive reciproche.</span><span class="sxs-lookup"><span data-stu-id="98172-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="98172-125">Per un esempio, vedere la sezione si escludono a vicenda tipi ricorsiva.</span><span class="sxs-lookup"><span data-stu-id="98172-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="98172-126">Costruttori</span><span class="sxs-lookup"><span data-stu-id="98172-126">Constructors</span></span>

<span data-ttu-id="98172-127">Il costruttore è codice che crea un'istanza del tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="98172-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="98172-128">Costruttori di classi funzionano in modo diverso in F# rispetto ai colleghi in altri linguaggi .NET.</span><span class="sxs-lookup"><span data-stu-id="98172-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="98172-129">In un F# classe, è sempre presente un costruttore primario i cui argomenti sono descritti nel `parameter-list` che segue il nome del tipo e il cui corpo è costituito il `let` (e `let rec`) associazioni all'inizio della dichiarazione di classe e il `do` associazioni che seguono.</span><span class="sxs-lookup"><span data-stu-id="98172-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="98172-130">Gli argomenti del costruttore primario sono nell'ambito della dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="98172-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="98172-131">È possibile aggiungere costruttori aggiuntivi utilizzando la `new` (parola chiave) per aggiungere un membro, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="98172-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="98172-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="98172-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="98172-133">Il corpo del costruttore della nuova deve richiamare il costruttore primario specificato nella parte superiore della dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="98172-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="98172-134">Nell'esempio seguente illustra questo concetto.</span><span class="sxs-lookup"><span data-stu-id="98172-134">The following example illustrates this concept.</span></span> <span data-ttu-id="98172-135">Nel codice seguente, `MyClass` dispone di due costruttori, un costruttore primario che accetta due argomenti e un altro costruttore che non accetta argomenti.</span><span class="sxs-lookup"><span data-stu-id="98172-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="98172-136">Let e associazioni do</span><span class="sxs-lookup"><span data-stu-id="98172-136">let and do Bindings</span></span>

<span data-ttu-id="98172-137">Il `let` e `do` associazioni in una definizione di classe costituiscono il corpo del costruttore della classe primaria e pertanto vengono eseguiti ogni volta che viene creata un'istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="98172-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="98172-138">Se un `let` associazione è una funzione, quindi viene compilato in un membro.</span><span class="sxs-lookup"><span data-stu-id="98172-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="98172-139">Se il `let` binding è un valore che non viene usato in qualsiasi funzione o un membro, quindi viene compilato in una variabile locale per il costruttore.</span><span class="sxs-lookup"><span data-stu-id="98172-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="98172-140">In caso contrario, viene compilato in un campo della classe.</span><span class="sxs-lookup"><span data-stu-id="98172-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="98172-141">Il `do` espressioni che seguono vengono compilate nel costruttore primario ed eseguire il codice di inizializzazione per ogni istanza.</span><span class="sxs-lookup"><span data-stu-id="98172-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="98172-142">Poiché i costruttori aggiuntivi sempre chiamare il costruttore principale, il `let` associazioni e `do` vengono sempre eseguite, indipendentemente da quale costruttore viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="98172-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="98172-143">I campi che vengono creati da `let` associazioni sono accessibili nel corso dei metodi e proprietà della classe; tuttavia, non è accessibile da metodi statici, anche se i metodi statici accettare una variabile di istanza come parametro.</span><span class="sxs-lookup"><span data-stu-id="98172-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="98172-144">Essi non è accessibile tramite l'autoidentificatore, se presente.</span><span class="sxs-lookup"><span data-stu-id="98172-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="98172-145">Autoidentificatori</span><span class="sxs-lookup"><span data-stu-id="98172-145">Self Identifiers</span></span>

<span data-ttu-id="98172-146">Oggetto *autoidentificatore* è un nome che rappresenta l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="98172-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="98172-147">Sono simili a autoidentificatori il `this` parola chiave in c# o C++ o `Me` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="98172-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="98172-148">È possibile definire un identificatore automatico in due modi diversi, a seconda che si voglia l'autoidentificatore nell'ambito per l'intera definizione di classe o solo per un singolo metodo.</span><span class="sxs-lookup"><span data-stu-id="98172-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="98172-149">Per definire un identificatore automatico per l'intera classe, usare il `as` (parola chiave) dopo la parentesi di chiusura del parametro del costruttore elencare e specificare il nome dell'identificatore.</span><span class="sxs-lookup"><span data-stu-id="98172-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="98172-150">Per definire un identificatore automatico per un solo metodo, fornire l'autoidentificatore nella dichiarazione del membro, appena prima del nome del metodo e un punto (.) come separatore.</span><span class="sxs-lookup"><span data-stu-id="98172-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="98172-151">Esempio di codice seguente illustra due modi per creare un identificatore utente.</span><span class="sxs-lookup"><span data-stu-id="98172-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="98172-152">Nella prima riga, il `as` parola chiave viene usata per definire l'autoidentificatore.</span><span class="sxs-lookup"><span data-stu-id="98172-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="98172-153">Nella quinta riga, l'identificatore `this` viene usato per definire un identificatore utente il cui ambito è limitato al metodo `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="98172-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="98172-154">A differenza di altri linguaggi .NET, è possibile denominare l'autoidentificatore come preferisci; non è limitato ai nomi, ad esempio `self`, `Me`, o `this`.</span><span class="sxs-lookup"><span data-stu-id="98172-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="98172-155">Stesso identificatore dichiarato con la `as` parola chiave non viene inizializzata finché dopo il `let` associazioni vengono eseguite.</span><span class="sxs-lookup"><span data-stu-id="98172-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="98172-156">Pertanto, non può essere usato nel `let` associazioni.</span><span class="sxs-lookup"><span data-stu-id="98172-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="98172-157">È possibile usare l'autoidentificatore nel `do` sezione delle associazioni.</span><span class="sxs-lookup"><span data-stu-id="98172-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="98172-158">Parametri di tipo generico</span><span class="sxs-lookup"><span data-stu-id="98172-158">Generic Type Parameters</span></span>

<span data-ttu-id="98172-159">Parametri di tipo generico specificati parentesi angolari (`<` e `>`), sotto forma di una virgoletta singola, seguita da un identificatore.</span><span class="sxs-lookup"><span data-stu-id="98172-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="98172-160">Più parametri di tipo generico sono separati da virgole.</span><span class="sxs-lookup"><span data-stu-id="98172-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="98172-161">Il parametro di tipo generico è nell'ambito della dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="98172-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="98172-162">Esempio di codice seguente viene illustrato come specificare i parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="98172-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="98172-163">Gli argomenti di tipo vengono dedotti quando viene utilizzato il tipo.</span><span class="sxs-lookup"><span data-stu-id="98172-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="98172-164">Nel codice seguente, il tipo dedotto è una sequenza di tuple.</span><span class="sxs-lookup"><span data-stu-id="98172-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="98172-165">Impostazione dell'ereditarietà</span><span class="sxs-lookup"><span data-stu-id="98172-165">Specifying Inheritance</span></span>

<span data-ttu-id="98172-166">Il `inherit` clausola identifica la classe di base diretta, se presente.</span><span class="sxs-lookup"><span data-stu-id="98172-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="98172-167">In F#, solo uno diretto della classe base è consentita.</span><span class="sxs-lookup"><span data-stu-id="98172-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="98172-168">Interfacce implementate da una classe non vengono considerate classi base.</span><span class="sxs-lookup"><span data-stu-id="98172-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="98172-169">Le interfacce vengono discussi nel [interfacce](Interfaces.md) argomento.</span><span class="sxs-lookup"><span data-stu-id="98172-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="98172-170">È possibile accedere i metodi e le proprietà della classe base dalla classe derivata usando la parola chiave del linguaggio `base` come identificatore, seguito da un punto (.) e il nome del membro.</span><span class="sxs-lookup"><span data-stu-id="98172-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="98172-171">Per altre informazioni, vedere [Ereditarietà](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="98172-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="98172-172">Sezione membri</span><span class="sxs-lookup"><span data-stu-id="98172-172">Members Section</span></span>

<span data-ttu-id="98172-173">È possibile definire statico o i metodi di istanza, le proprietà, le implementazioni dell'interfaccia, i membri astratti, le dichiarazioni di eventi e costruttori aggiuntivi in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="98172-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="98172-174">Let ed effettuare associazioni non può trovarsi in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="98172-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="98172-175">Poiché è possibile aggiungere membri a una varietà di F# tipi oltre alle classi, vengono descritti in un argomento separato [membri](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="98172-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="98172-176">Si escludono a vicenda tipi ricorsiva</span><span class="sxs-lookup"><span data-stu-id="98172-176">Mutually Recursive Types</span></span>

<span data-ttu-id="98172-177">Quando si definiscono i tipi che fanno riferimento a altro in modo circolare, è unire le definizioni dei tipi tramite la `and` (parola chiave).</span><span class="sxs-lookup"><span data-stu-id="98172-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="98172-178">Il `and` parola chiave sostituisce il `type` la parola chiave nel tutto eccetto la prima definizione, come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="98172-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="98172-179">L'output è un elenco di tutti i file nella directory corrente.</span><span class="sxs-lookup"><span data-stu-id="98172-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="98172-180">Quando usare le classi, unioni discriminate, record e strutture</span><span class="sxs-lookup"><span data-stu-id="98172-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="98172-181">Data la varietà di tipi tra cui scegliere, è necessario avere una buona conoscenza di ciò che è progettato per ogni tipo per selezionare il tipo appropriato per una determinata situazione.</span><span class="sxs-lookup"><span data-stu-id="98172-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="98172-182">Classi sono progettate per l'uso in contesti di programmazione orientata agli oggetti.</span><span class="sxs-lookup"><span data-stu-id="98172-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="98172-183">La programmazione orientata agli oggetti è il paradigma principale usato dalle applicazioni che sono destinate a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="98172-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="98172-184">Se il F# dispone di codice lavorare a stretto contatto con .NET Framework o a un'altra libreria orientate a oggetti e soprattutto se è necessario estendere da un sistema di tipi orientate a oggetti, ad esempio una libreria dell'interfaccia utente, le classi sono probabilmente appropriate.</span><span class="sxs-lookup"><span data-stu-id="98172-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="98172-185">Se non si interagisce strettamente con il codice orientate a oggetti o se si sta scrivendo codice che è indipendente e pertanto protetti contro il frequente interazione con codice orientate a oggetti, è consigliabile usare record e unioni discriminate.</span><span class="sxs-lookup"><span data-stu-id="98172-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="98172-186">Un singolo, anche pensiero – out unione discriminata, insieme a codice, corrispondenza dei appropriato può spesso essere utilizzato come un'alternativa più semplice per una gerarchia di oggetti.</span><span class="sxs-lookup"><span data-stu-id="98172-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="98172-187">Per altre informazioni sulle unioni discriminate, vedere [unioni discriminate](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="98172-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="98172-188">I record hanno il vantaggio di essere più semplice rispetto alle classi, ma non sono appropriati quando le richieste di un tipo di superare i risultati ottenuti con la loro semplicità.</span><span class="sxs-lookup"><span data-stu-id="98172-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="98172-189">I record sono fondamentalmente aggregazioni semplici di valori, senza costruttori separati che possono eseguire azioni personalizzate, senza campi nascosti e senza alcuna implementazione dell'ereditarietà o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="98172-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="98172-190">Anche se i membri, ad esempio proprietà e metodi possono essere aggiunti ai record per rendere il proprio comportamento più complesso, i campi archiviati in un record sono comunque una semplice aggregazione di valori.</span><span class="sxs-lookup"><span data-stu-id="98172-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="98172-191">Per altre informazioni sui record, vedere [record](records.md).</span><span class="sxs-lookup"><span data-stu-id="98172-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="98172-192">Le strutture sono utili anche per piccole aggregazioni di dati, ma si differenziano dalle classi e i record in quanto sono tipi di valore .NET.</span><span class="sxs-lookup"><span data-stu-id="98172-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="98172-193">Classi e i record sono i tipi di riferimento .NET.</span><span class="sxs-lookup"><span data-stu-id="98172-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="98172-194">La semantica dei tipi di valore e tipi di riferimento è diversa in quanto i tipi di valore vengono passati per valore.</span><span class="sxs-lookup"><span data-stu-id="98172-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="98172-195">Ciò significa che vengono copiati in bit per bit quando vengono passati come parametro o restituiti da una funzione.</span><span class="sxs-lookup"><span data-stu-id="98172-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="98172-196">Vengono inoltre archiviate nello stack o, se vengono usati come un campo, incorporato all'interno dell'oggetto padre anziché archiviati nel proprio percorso separato nell'heap.</span><span class="sxs-lookup"><span data-stu-id="98172-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="98172-197">Pertanto, le strutture sono appropriate per i dati utilizzati di frequente quando il sovraccarico dovuto all'accesso l'heap è un problema.</span><span class="sxs-lookup"><span data-stu-id="98172-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="98172-198">Per altre informazioni sulle strutture, vedere [strutture](structures.md).</span><span class="sxs-lookup"><span data-stu-id="98172-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="98172-199">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="98172-199">See also</span></span>

- [<span data-ttu-id="98172-200">Riferimenti per il linguaggio F#</span><span class="sxs-lookup"><span data-stu-id="98172-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="98172-201">Membri</span><span class="sxs-lookup"><span data-stu-id="98172-201">Members</span></span>](members/index.md)
- [<span data-ttu-id="98172-202">Ereditarietà</span><span class="sxs-lookup"><span data-stu-id="98172-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="98172-203">Interfacce</span><span class="sxs-lookup"><span data-stu-id="98172-203">Interfaces</span></span>](interfaces.md)
