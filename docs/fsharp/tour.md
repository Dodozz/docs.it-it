---
title: Panoramica di F#
description: Esaminare alcune delle principali funzionalità del linguaggio in questa presentazione con esempi di codice di programmazione F#.
ms.date: 11/06/2018
ms.openlocfilehash: 4b3ec7fd2c42712440ea7d7045c560ab20390b45
ms.sourcegitcommit: 16aefeb2d265e69c0d80967580365fabf0c5d39a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/16/2019
ms.locfileid: "58125577"
---
# <a name="tour-of-f"></a><span data-ttu-id="3b6bd-103">Panoramica di F\#</span><span class="sxs-lookup"><span data-stu-id="3b6bd-103">Tour of F\#</span></span>

<span data-ttu-id="3b6bd-104">Il modo migliore per informazioni su F# è per leggere e scrivere codice F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="3b6bd-105">Questo articolo verrà agire come un tour dettagliato alcune delle principali funzionalità del linguaggio F# e offrono alcuni frammenti di codice che è possibile eseguire nel computer.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="3b6bd-106">Per altre informazioni sull'impostazione di un ambiente di sviluppo, consultare [introduttiva](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-106">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="3b6bd-107">Esistono due concetti primari in F#: tipi e funzioni.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="3b6bd-108">Questa esercitazione verrà illustrate le funzionalità del linguaggio che rientrano in queste due concetti.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="3b6bd-109">L'esecuzione del codice online</span><span class="sxs-lookup"><span data-stu-id="3b6bd-109">Executing the code online</span></span>

<span data-ttu-id="3b6bd-110">Se non hai F# installato nel computer, è possibile eseguire tutti gli esempi in linea con il [REPL Fable](https://fable.io/repl/).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-110">If you don't have F# installed on your machine, you can execute all of the samples online with the [Fable REPL](https://fable.io/repl/).</span></span> <span data-ttu-id="3b6bd-111">Fable è un sottolinguaggio di F# che viene eseguita direttamente nel browser.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="3b6bd-112">Per visualizzare gli esempi che seguono in REPL, consultare **esempi > Scopri > Panoramica del F#**  nella barra dei menu a sinistra delle transazioni replica Fable</span><span class="sxs-lookup"><span data-stu-id="3b6bd-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="3b6bd-113">Funzioni e moduli</span><span class="sxs-lookup"><span data-stu-id="3b6bd-113">Functions and Modules</span></span>

<span data-ttu-id="3b6bd-114">Le parti più importanti di qualsiasi programma F# vengono ***funzioni*** organizzato ***moduli***.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="3b6bd-115">[Le funzioni](language-reference/functions/index.md) eseguiti in input per produrre output e sono organizzati sotto [moduli](language-reference/modules.md), che rappresentano il modo principale si raggruppano le cose in F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-115">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="3b6bd-116">Vengono definite usando il [ `let` associazione](language-reference/functions/let-bindings.md), cui assegnare un nome di funzione e definire i relativi argomenti.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-116">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="3b6bd-117">`let` le associazioni sono anche come associare un valore a un nome simile a una variabile in altri linguaggi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="3b6bd-118">`let` le associazioni sono ***non modificabile*** per impostazione predefinita, il che significa che una volta un valore o una funzione associata a un nome, non può essere modificata sul posto.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="3b6bd-119">A differenza delle variabili in altre lingue, ovvero si tratta ***modificabile***, vale a dire i relativi valori possono essere modificati in qualsiasi punto nel tempo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="3b6bd-120">Se è necessaria un'associazione modificabile, è possibile usare `let mutable ...` sintassi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="3b6bd-121">I numeri, valori booleani e stringhe</span><span class="sxs-lookup"><span data-stu-id="3b6bd-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="3b6bd-122">Come un linguaggio .NET, F# supporta la stessa sottostante [i tipi primitivi](language-reference/primitive-types.md) che esistono in .NET.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="3b6bd-123">Ecco come vari tipi numerici sono rappresentati in F#:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="3b6bd-124">Ecco quali valori booleani ed esecuzione di base per la logica condizionale è simile a:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="3b6bd-125">Ed ecco quali basic [stringa](language-reference/strings.md) manipolazione è simile a:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-125">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="3b6bd-126">Tuple</span><span class="sxs-lookup"><span data-stu-id="3b6bd-126">Tuples</span></span>

<span data-ttu-id="3b6bd-127">[Le tuple](language-reference/tuples.md) sono un grande vantaggio in F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-127">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="3b6bd-128">Sono un raggruppamento di valori senza nome, ma ordinati, che possono essere considerati come valori stessi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="3b6bd-129">Devono essere considerati come valori che vengono aggregati da altri valori.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="3b6bd-130">Hanno diversi scopi, ad esempio comodamente la restituzione di più valori da una funzione o il raggruppamento dei valori per alcuni motivi di praticità ad hoc.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="3b6bd-131">A partire da F# 4.1, è anche possibile creare `struct` Tuple.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-131">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="3b6bd-132">Questi anche interagire completamente con le tuple 7 # e Visual Basic 15 C, che sono anche `struct` tuple:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="3b6bd-133">È importante notare che perché `struct` le tuple sono tipi valore, non possono essere convertiti in modo implicito per fare riferimento le tuple, o viceversa.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="3b6bd-134">È necessario convertire in modo esplicito tra una tupla di riferimento e struct.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="3b6bd-135">Pipeline e composizione</span><span class="sxs-lookup"><span data-stu-id="3b6bd-135">Pipelines and Composition</span></span>

<span data-ttu-id="3b6bd-136">Inviare tramite pipe gli operatori, ad esempio `|>` vengono usate spesso durante l'elaborazione dati in F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="3b6bd-137">Questi operatori sono funzioni che consentono di stabilire una "pipeline" delle funzioni in modo flessibile.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="3b6bd-138">Nell'esempio seguente illustra come è possibile sfruttare i vantaggi di questi operatori per compilare una semplice pipeline funzionale:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="3b6bd-139">L'esempio precedente reso l'utilizzo di numerose funzionalità di F#, tra cui funzioni di elaborazione di elenco, funzioni di prima classe, e [applicazione parziale](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="3b6bd-140">Sebbene una conoscenza approfondita della ognuno di questi concetti può diventare piuttosto avanzata, dovrebbe essere chiaro con quanta facilità funzioni possono essere utilizzate per elaborare i dati durante la creazione di pipeline.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="3b6bd-141">Elenchi, matrici e sequenze</span><span class="sxs-lookup"><span data-stu-id="3b6bd-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="3b6bd-142">Elenchi, matrici e sequenze sono tre tipi di raccolta principale nella libreria di base F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="3b6bd-143">[Elenca](language-reference/lists.md) sono raccolte ordinate e non modificabile di elementi dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-143">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="3b6bd-144">Questi sono elenchi collegati singolarmente, ovvero che sono disponibili solo per l'enumerazione, ma una scelta insufficiente per l'accesso casuale e concatenazione se sono grandi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="3b6bd-145">Questa differenza di elenchi in altri linguaggi più diffusi, che in genere non utilizzano un elenco collegato singolarmente per rappresentare elenchi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="3b6bd-146">[Le matrici](language-reference/arrays.md) sono di dimensioni fisse, *modificabile* raccolte di elementi dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-146">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="3b6bd-147">Supportano l'accesso casuale veloce degli elementi e sono più veloci rispetto a F# perché tali elenchi sono contigui solo blocchi di memoria.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="3b6bd-148">[Le sequenze](language-reference/sequences.md) sono una serie logica di elementi, tutti dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-148">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="3b6bd-149">Si tratta di un tipo più generale di elenchi e matrici, in grado di essere il "visualizzazione" di qualsiasi serie logica di elementi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="3b6bd-150">Sono anche mettere in evidenza perché possono essere ***lazy***, il che significa che gli elementi possono essere calcolati solo quando sono necessari.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="3b6bd-151">Funzioni ricorsive</span><span class="sxs-lookup"><span data-stu-id="3b6bd-151">Recursive Functions</span></span>

<span data-ttu-id="3b6bd-152">L'elaborazione di raccolte o le sequenze di elementi avviene in genere con [ricorsione](language-reference/functions/index.md#recursive-functions) in F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-152">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="3b6bd-153">Sebbene F# offre supporto per i cicli e programmazione imperativa, la ricorsione è preferibile perché risulta più semplice garantire la correttezza.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="3b6bd-154">Nell'esempio seguente usa i criteri di ricerca tramite la `match` espressione.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="3b6bd-155">Questo costrutto fondamentale è trattato più avanti in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="3b6bd-156">F# inoltre offre supporto completo per l'ottimizzazione chiamata Tail, che è possibile ottimizzare le chiamate ricorsive in modo che siano il più velocemente un costrutto di ciclo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="3b6bd-157">Record e i tipi di unione discriminati</span><span class="sxs-lookup"><span data-stu-id="3b6bd-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="3b6bd-158">Record e i tipi di unione sono due tipi di dati fondamentali usati nel codice F# e sono in genere il modo migliore per rappresentare i dati in un programma F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="3b6bd-159">Anche se ciò li rende simile alle classi in altri linguaggi, una delle loro differenze principali è la semantica di uguaglianza strutturale.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="3b6bd-160">Ciò significa che sono confrontabili "in modo nativo" e verificarne l'uguaglianza è semplice: controllare solo se uno è uguale a altro.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="3b6bd-161">[I record](language-reference/records.md) sono un'aggregazione di valori denominati, con i membri facoltativi (ad esempio metodi).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-161">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="3b6bd-162">Se si ha familiarità con c# o Java, si dovrebbe risultare simile a oggetti poco o Pojo - solo con l'uguaglianza strutturale e meno conferimento.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="3b6bd-163">A partire da F# 4.1, si può anche rappresentare record come `struct`s.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-163">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="3b6bd-164">Questa operazione viene eseguita con il `[<Struct>]` attributo:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="3b6bd-165">[Unioni discriminate (DUs)](language-reference/discriminated-unions.md) sono valori che può essere un numero di moduli denominati o case.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-165">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="3b6bd-166">Dati archiviati nel tipo possono essere uno dei diversi valori distinti.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="3b6bd-167">È anche possibile usare come DUs *unioni discriminate Case singolo*, alla assistenza tramite i tipi primitivi di modellazione del dominio.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="3b6bd-168">Spesso, le stringhe e altri tipi primitivi vengono usati per rappresentare un elemento e vengono quindi assegnati un significato particolare.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="3b6bd-169">Tuttavia, utilizzando solo la rappresentazione dei dati primitiva può comportare erroneamente assegnando un valore non corretto.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="3b6bd-170">Che rappresenta ogni tipo di informazioni come un'unione case singolo distinta può imporre la correttezza in questo scenario.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="3b6bd-171">Come illustrato nell'esempio precedente, per ottenere il valore sottostante in un case singolo unione discriminata, deve esplicitamente unwrap.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="3b6bd-172">Inoltre, DUs supportano anche le definizioni ricorsiva, consentendo di rappresentare facilmente alberi e intrinsecamente dati ricorsivi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="3b6bd-173">Ad esempio, ecco come è possibile rappresentare un albero di ricerca binario con `exists` e `insert` funzioni.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="3b6bd-174">Poiché DUs consentono di rappresentare la struttura ricorsiva dell'albero nel tipo di dati, opera su tale struttura ricorsiva è semplice e garantisce la correttezza.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="3b6bd-175">È anche supportata in Criteri di ricerca, come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="3b6bd-176">Inoltre, è possibile rappresentare come DUs `struct`con il `[<Struct>]` attributo:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="3b6bd-177">Tuttavia, esistono due gli aspetti da tenere presenti quando si esegue questa operazione:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="3b6bd-178">Uno struct di unità di database non può essere definito in modo ricorsivo.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="3b6bd-179">Uno struct di unità di database deve avere nomi univoci per ognuno dei relativi case.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="3b6bd-180">Impossibilità di seguire il codice precedente comporterà un errore di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="3b6bd-181">Criteri di ricerca</span><span class="sxs-lookup"><span data-stu-id="3b6bd-181">Pattern Matching</span></span>

<span data-ttu-id="3b6bd-182">[Criteri di corrispondenza](language-reference/pattern-matching.md) è la funzionalità del linguaggio F# che consente la correttezza per l'uso di tipi F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-182">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="3b6bd-183">Negli esempi precedenti, si sarà probabilmente notato qualche `match x with ...` sintassi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="3b6bd-184">Questo costrutto consente al compilatore, che può comprendere la "forma" dei tipi di dati, per forzare per conto di tutti i casi possibili quando utilizza un tipo di dati tramite ciò che è noto come esaustivo criteri di ricerca.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="3b6bd-185">Ciò è incredibilmente potente per la correttezza e prosegue senza soste utilizzabile per "solleva" che normalmente sarebbe un problema di runtime in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="3b6bd-186">Qualcosa si può notare è l'uso del `_` pattern.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="3b6bd-187">Questo è noto come il [modello carattere jolly](language-reference/pattern-matching.md#wildcard-pattern), che è un concetto viene espresso indicando ", non mi preoccupo qualcosa What ' s".</span><span class="sxs-lookup"><span data-stu-id="3b6bd-187">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="3b6bd-188">Anche se utile, è possibile ignorare accidentalmente esaustivo criteri di ricerca e non è più vantaggioso si applicano le regole in fase di compilazione se non si presta attenzione nell'uso `_`.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="3b6bd-189">Risulta particolarmente utile quando non si è interessati determinate parti di un tipo scomposto quando modello corrispondenza o la clausola finale quando si sono enumerati tutti i casi significativi in un'espressione di corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="3b6bd-190">[Criteri attivi](language-reference/active-patterns.md) sono un altro costrutto potente da usare con criteri di ricerca.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-190">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="3b6bd-191">Consentono di suddividere i dati di input in moduli personalizzati, scomporli nel sito di chiamata match pattern.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-191">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="3b6bd-192">Possono anche essere parametrizzati, consentendo in tal modo per definire la partizione come una funzione.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-192">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="3b6bd-193">Continuando l'esempio precedente per supportare i modelli attivi simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="3b6bd-193">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="3b6bd-194">Tipi facoltativi</span><span class="sxs-lookup"><span data-stu-id="3b6bd-194">Optional Types</span></span>

<span data-ttu-id="3b6bd-195">Un caso speciale di unione discriminata di tipi è il tipo di opzione, è pertanto utile che fa parte della libreria di base F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-195">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="3b6bd-196">[Il tipo di opzione](language-reference/options.md) costituisce un tipo che rappresenta uno dei due casi: un valore o niente affatto.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-196">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="3b6bd-197">Viene usato in qualsiasi scenario in cui un valore può o non può generare da un'operazione specifica.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-197">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="3b6bd-198">In questo modo quindi tenere conto per entrambi i casi, rendendolo rappresentano un problema in fase di compilazione anziché a un problema di runtime.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-198">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="3b6bd-199">Questi vengono spesso usati per le API in cui `null` viene usato per rappresentare "nothing", invece, eliminando così la necessità di preoccuparsi `NullReferenceException` in molte circostanze.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-199">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="3b6bd-200">Unità di misura</span><span class="sxs-lookup"><span data-stu-id="3b6bd-200">Units of Measure</span></span>

<span data-ttu-id="3b6bd-201">Una funzionalità univoca di sistema di tipi F# è la possibilità di fornire un contesto per i valori letterali numerici tramite unità di misura.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-201">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="3b6bd-202">[Unità di misura](language-reference/units-of-measure.md) consentono di associare un tipo numerico a un'unità, ad esempio i contatori, e hanno funzioni eseguiti in unità anziché valori letterali numerici.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-202">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="3b6bd-203">Ciò consente al compilatore di verificare che i tipi di valori letterali numerici passati ha senso in un determinato contesto, eliminando così gli errori di runtime associato con questo tipo di attività.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-203">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="3b6bd-204">La libreria F# Core definisce molti tipi di unità di sistema internazionale di misura e le conversioni di unità.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-204">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="3b6bd-205">Per altre informazioni, consultare il [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-205">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="3b6bd-206">Classi e interfacce</span><span class="sxs-lookup"><span data-stu-id="3b6bd-206">Classes and Interfaces</span></span>

<span data-ttu-id="3b6bd-207">F# offre anche il supporto completo per le classi di .NET [interfacce](language-reference/interfaces.md), [classi astratte](language-reference/abstract-classes.md), [ereditarietà](language-reference/inheritance.md)e così via.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-207">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="3b6bd-208">[Le classi](language-reference/classes.md) sono tipi che rappresentano gli oggetti .NET, che possono avere proprietà, metodi ed eventi come relativo [membri](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-208">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="3b6bd-209">Definizione delle classi generiche è altrettanto semplice.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-209">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="3b6bd-210">Per implementare un'interfaccia, è possibile usare `interface ... with` sintassi o un [espressione oggetto](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="3b6bd-210">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="3b6bd-211">Quali tipi di utilizzo</span><span class="sxs-lookup"><span data-stu-id="3b6bd-211">Which Types to Use</span></span>

<span data-ttu-id="3b6bd-212">La presenza di classi, record, unioni discriminate e tuple conduce a una domanda importante: quale è opportuno utilizzare?</span><span class="sxs-lookup"><span data-stu-id="3b6bd-212">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="3b6bd-213">Come la maggior parte delle tutti gli elementi in uno scenario, la risposta varia a seconda delle circostanze.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-213">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="3b6bd-214">Le tuple sono ideali per la restituzione di più valori da una funzione e l'utilizzo di un'aggregazione ad-hoc di valori sotto forma di valore stesso.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-214">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="3b6bd-215">I record sono un "gradino sopra" da tuple, visto denominato etichette e il supporto per membri facoltativi.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-215">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="3b6bd-216">Sono ideali per una rappresentazione informale di dati in transito tramite il programma.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-216">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="3b6bd-217">Perché presentano l'uguaglianza strutturale, essi sono facili da usare con il confronto.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-217">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="3b6bd-218">Unioni discriminate sono molti gli usi, ma il vantaggio principale consiste nel poter utilizzarli in combinazione con criteri di ricerca per conto di tutte le possibili "forme" che può avere un tipo di dati.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-218">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="3b6bd-219">Le classi sono ideali per un numero enorme di motivi, ad esempio quando è necessario rappresentare le informazioni e anche associare tali informazioni per la funzionalità.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-219">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="3b6bd-220">Come regola generale, quando si dispone di funzionalità che concettualmente è collegata ad alcuni dati, uso di classi e i principi della programmazione orientata a oggetti rappresenta un enorme vantaggio.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-220">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="3b6bd-221">Le classi sono anche il tipo di dati preferito quando si interagisce con c# e Visual Basic, poiché questi linguaggi usano classi per quasi tutte le funzioni.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-221">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="3b6bd-222">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="3b6bd-222">Next Steps</span></span>

<span data-ttu-id="3b6bd-223">Ora che si è visto alcune delle principali funzionalità del linguaggio, dovrebbe essere pronti a scrivere i primi programmi F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-223">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="3b6bd-224">Consulta [introduttiva](tutorials/getting-started/index.md) per informazioni su come configurare l'ambiente di sviluppo e scrivere il codice.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-224">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="3b6bd-225">I passaggi successivi per ottenere ulteriori possono essere qualsiasi, ma è consigliabile [Introduzione alla programmazione funzionale in F# ](introduction-to-functional-programming/index.md) per acquisire familiarità con concetti di programmazione funzionale.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-225">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="3b6bd-226">Questi saranno essenziali nella creazione di applicazioni affidabili in F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-226">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="3b6bd-227">Inoltre, consultare il [riferimenti al linguaggio F#](language-reference/index.md) per visualizzare una raccolta completa di contenuti concettuali su F#.</span><span class="sxs-lookup"><span data-stu-id="3b6bd-227">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
